        -:    0:Source:packet.c
        -:    0:Programs:78
        -:    1:/* $OpenBSD: packet.c,v 1.243 2016/10/11 21:47:45 djm Exp $ */
        -:    2:/*
        -:    3: * Author: Tatu Ylonen <ylo@cs.hut.fi>
        -:    4: * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
        -:    5: *                    All rights reserved
        -:    6: * This file contains code implementing the packet protocol and communication
        -:    7: * with the other side.  This same code is used both on client and server side.
        -:    8: *
        -:    9: * As far as I am concerned, the code I have written for this software
        -:   10: * can be used freely for any purpose.  Any derived versions of this
        -:   11: * software must be clearly marked as such, and if the derived work is
        -:   12: * incompatible with the protocol description in the RFC file, it must be
        -:   13: * called by a name other than "ssh" or "Secure Shell".
        -:   14: *
        -:   15: *
        -:   16: * SSH2 packet format added by Markus Friedl.
        -:   17: * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
        -:   18: *
        -:   19: * Redistribution and use in source and binary forms, with or without
        -:   20: * modification, are permitted provided that the following conditions
        -:   21: * are met:
        -:   22: * 1. Redistributions of source code must retain the above copyright
        -:   23: *    notice, this list of conditions and the following disclaimer.
        -:   24: * 2. Redistributions in binary form must reproduce the above copyright
        -:   25: *    notice, this list of conditions and the following disclaimer in the
        -:   26: *    documentation and/or other materials provided with the distribution.
        -:   27: *
        -:   28: * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
        -:   29: * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
        -:   30: * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   31: * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
        -:   32: * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
        -:   33: * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   34: * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   35: * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   36: * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
        -:   37: * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   38: */
        -:   39:
        -:   40:#include "includes.h"
        -:   41:
        -:   42:#include <sys/types.h>
        -:   43:#include "openbsd-compat/sys-queue.h"
        -:   44:#include <sys/socket.h>
        -:   45:#ifdef HAVE_SYS_TIME_H
        -:   46:# include <sys/time.h>
        -:   47:#endif
        -:   48:
        -:   49:#include <netinet/in.h>
        -:   50:#include <netinet/ip.h>
        -:   51:#include <arpa/inet.h>
        -:   52:
        -:   53:#include <errno.h>
        -:   54:#include <netdb.h>
        -:   55:#include <stdarg.h>
        -:   56:#include <stdio.h>
        -:   57:#include <stdlib.h>
        -:   58:#include <string.h>
        -:   59:#include <unistd.h>
        -:   60:#include <limits.h>
        -:   61:#include <signal.h>
        -:   62:#include <time.h>
        -:   63:
        -:   64:#include <zlib.h>
        -:   65:
        -:   66:#include "buffer.h"	/* typedefs XXX */
        -:   67:#include "key.h"	/* typedefs XXX */
        -:   68:
        -:   69:#include "xmalloc.h"
        -:   70:#include "crc32.h"
        -:   71:#include "deattack.h"
        -:   72:#include "compat.h"
        -:   73:#include "ssh1.h"
        -:   74:#include "ssh2.h"
        -:   75:#include "cipher.h"
        -:   76:#include "sshkey.h"
        -:   77:#include "kex.h"
        -:   78:#include "digest.h"
        -:   79:#include "mac.h"
        -:   80:#include "log.h"
        -:   81:#include "canohost.h"
        -:   82:#include "misc.h"
        -:   83:#include "channels.h"
        -:   84:#include "ssh.h"
        -:   85:#include "packet.h"
        -:   86:#include "ssherr.h"
        -:   87:#include "sshbuf.h"
        -:   88:
        -:   89:#ifdef PACKET_DEBUG
        -:   90:#define DBG(x) x
        -:   91:#else
        -:   92:#define DBG(x)
        -:   93:#endif
        -:   94:
        -:   95:#define PACKET_MAX_SIZE (256 * 1024)
        -:   96:
        -:   97:struct packet_state {
        -:   98:	u_int32_t seqnr;
        -:   99:	u_int32_t packets;
        -:  100:	u_int64_t blocks;
        -:  101:	u_int64_t bytes;
        -:  102:};
        -:  103:
        -:  104:struct packet {
        -:  105:	TAILQ_ENTRY(packet) next;
        -:  106:	u_char type;
        -:  107:	struct sshbuf *payload;
        -:  108:};
        -:  109:
        -:  110:struct session_state {
        -:  111:	/*
        -:  112:	 * This variable contains the file descriptors used for
        -:  113:	 * communicating with the other side.  connection_in is used for
        -:  114:	 * reading; connection_out for writing.  These can be the same
        -:  115:	 * descriptor, in which case it is assumed to be a socket.
        -:  116:	 */
        -:  117:	int connection_in;
        -:  118:	int connection_out;
        -:  119:
        -:  120:	/* Protocol flags for the remote side. */
        -:  121:	u_int remote_protocol_flags;
        -:  122:
        -:  123:	/* Encryption context for receiving data.  Only used for decryption. */
        -:  124:	struct sshcipher_ctx *receive_context;
        -:  125:
        -:  126:	/* Encryption context for sending data.  Only used for encryption. */
        -:  127:	struct sshcipher_ctx *send_context;
        -:  128:
        -:  129:	/* Buffer for raw input data from the socket. */
        -:  130:	struct sshbuf *input;
        -:  131:
        -:  132:	/* Buffer for raw output data going to the socket. */
        -:  133:	struct sshbuf *output;
        -:  134:
        -:  135:	/* Buffer for the partial outgoing packet being constructed. */
        -:  136:	struct sshbuf *outgoing_packet;
        -:  137:
        -:  138:	/* Buffer for the incoming packet currently being processed. */
        -:  139:	struct sshbuf *incoming_packet;
        -:  140:
        -:  141:	/* Scratch buffer for packet compression/decompression. */
        -:  142:	struct sshbuf *compression_buffer;
        -:  143:
        -:  144:	/* Incoming/outgoing compression dictionaries */
        -:  145:	z_stream compression_in_stream;
        -:  146:	z_stream compression_out_stream;
        -:  147:	int compression_in_started;
        -:  148:	int compression_out_started;
        -:  149:	int compression_in_failures;
        -:  150:	int compression_out_failures;
        -:  151:
        -:  152:	/*
        -:  153:	 * Flag indicating whether packet compression/decompression is
        -:  154:	 * enabled.
        -:  155:	 */
        -:  156:	int packet_compression;
        -:  157:
        -:  158:	/* default maximum packet size */
        -:  159:	u_int max_packet_size;
        -:  160:
        -:  161:	/* Flag indicating whether this module has been initialized. */
        -:  162:	int initialized;
        -:  163:
        -:  164:	/* Set to true if the connection is interactive. */
        -:  165:	int interactive_mode;
        -:  166:
        -:  167:	/* Set to true if we are the server side. */
        -:  168:	int server_side;
        -:  169:
        -:  170:	/* Set to true if we are authenticated. */
        -:  171:	int after_authentication;
        -:  172:
        -:  173:	int keep_alive_timeouts;
        -:  174:
        -:  175:	/* The maximum time that we will wait to send or receive a packet */
        -:  176:	int packet_timeout_ms;
        -:  177:
        -:  178:	/* Session key information for Encryption and MAC */
        -:  179:	struct newkeys *newkeys[MODE_MAX];
        -:  180:	struct packet_state p_read, p_send;
        -:  181:
        -:  182:	/* Volume-based rekeying */
        -:  183:	u_int64_t max_blocks_in, max_blocks_out, rekey_limit;
        -:  184:
        -:  185:	/* Time-based rekeying */
        -:  186:	u_int32_t rekey_interval;	/* how often in seconds */
        -:  187:	time_t rekey_time;	/* time of last rekeying */
        -:  188:
        -:  189:	/* Session key for protocol v1 */
        -:  190:	u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
        -:  191:	u_int ssh1_keylen;
        -:  192:
        -:  193:	/* roundup current message to extra_pad bytes */
        -:  194:	u_char extra_pad;
        -:  195:
        -:  196:	/* XXX discard incoming data after MAC error */
        -:  197:	u_int packet_discard;
        -:  198:	size_t packet_discard_mac_already;
        -:  199:	struct sshmac *packet_discard_mac;
        -:  200:
        -:  201:	/* Used in packet_read_poll2() */
        -:  202:	u_int packlen;
        -:  203:
        -:  204:	/* Used in packet_send2 */
        -:  205:	int rekeying;
        -:  206:
        -:  207:	/* Used in ssh_packet_send_mux() */
        -:  208:	int mux;
        -:  209:
        -:  210:	/* Used in packet_set_interactive */
        -:  211:	int set_interactive_called;
        -:  212:
        -:  213:	/* Used in packet_set_maxsize */
        -:  214:	int set_maxsize_called;
        -:  215:
        -:  216:	/* One-off warning about weak ciphers */
        -:  217:	int cipher_warning_done;
        -:  218:
        -:  219:	/* SSH1 CRC compensation attack detector */
        -:  220:	struct deattack_ctx deattack;
        -:  221:
        -:  222:	/* Hook for fuzzing inbound packets */
        -:  223:	ssh_packet_hook_fn *hook_in;
        -:  224:	void *hook_in_ctx;
        -:  225:
        -:  226:	TAILQ_HEAD(, packet) outgoing;
        -:  227:};
        -:  228:
        -:  229:struct ssh *
        2:  230:ssh_alloc_session_state(void)
        -:  231:{
        2:  232:	struct ssh *ssh = NULL;
        2:  233:	struct session_state *state = NULL;
        -:  234:
        2:  235:	if ((ssh = calloc(1, sizeof(*ssh))) == NULL ||
        2:  236:	    (state = calloc(1, sizeof(*state))) == NULL ||
        4:  237:	    (state->input = sshbuf_new()) == NULL ||
        4:  238:	    (state->output = sshbuf_new()) == NULL ||
        4:  239:	    (state->outgoing_packet = sshbuf_new()) == NULL ||
        2:  240:	    (state->incoming_packet = sshbuf_new()) == NULL)
        -:  241:		goto fail;
        2:  242:	TAILQ_INIT(&state->outgoing);
        2:  243:	TAILQ_INIT(&ssh->private_keys);
        2:  244:	TAILQ_INIT(&ssh->public_keys);
        2:  245:	state->connection_in = -1;
        2:  246:	state->connection_out = -1;
        2:  247:	state->max_packet_size = 32768;
        2:  248:	state->packet_timeout_ms = -1;
        2:  249:	state->p_send.packets = state->p_read.packets = 0;
        2:  250:	state->initialized = 1;
        -:  251:	/*
        -:  252:	 * ssh_packet_send2() needs to queue packets until
        -:  253:	 * we've done the initial key exchange.
        -:  254:	 */
        2:  255:	state->rekeying = 1;
        2:  256:	ssh->state = state;
        2:  257:	return ssh;
        -:  258: fail:
    #####:  259:	if (state) {
    #####:  260:		sshbuf_free(state->input);
    #####:  261:		sshbuf_free(state->output);
    #####:  262:		sshbuf_free(state->incoming_packet);
    #####:  263:		sshbuf_free(state->outgoing_packet);
    #####:  264:		free(state);
        -:  265:	}
    #####:  266:	free(ssh);
    #####:  267:	return NULL;
        -:  268:}
        -:  269:
        -:  270:void
    #####:  271:ssh_packet_set_input_hook(struct ssh *ssh, ssh_packet_hook_fn *hook, void *ctx)
        -:  272:{
    #####:  273:	ssh->state->hook_in = hook;
    #####:  274:	ssh->state->hook_in_ctx = ctx;
    #####:  275:}
        -:  276:
        -:  277:/* Returns nonzero if rekeying is in progress */
        -:  278:int
     1126:  279:ssh_packet_is_rekeying(struct ssh *ssh)
        -:  280:{
     2252:  281:	return compat20 &&
     2252:  282:	    (ssh->state->rekeying || (ssh->kex != NULL && ssh->kex->done == 0));
        -:  283:}
        -:  284:
        -:  285:/*
        -:  286: * Sets the descriptors used for communication.  Disables encryption until
        -:  287: * packet_set_encryption_key is called.
        -:  288: */
        -:  289:struct ssh *
        2:  290:ssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)
        -:  291:{
        -:  292:	struct session_state *state;
        2:  293:	const struct sshcipher *none = cipher_by_name("none");
        -:  294:	int r;
        -:  295:
        2:  296:	if (none == NULL) {
    #####:  297:		error("%s: cannot load cipher 'none'", __func__);
    #####:  298:		return NULL;
        -:  299:	}
        2:  300:	if (ssh == NULL)
        2:  301:		ssh = ssh_alloc_session_state();
        2:  302:	if (ssh == NULL) {
    #####:  303:		error("%s: cound not allocate state", __func__);
    #####:  304:		return NULL;
        -:  305:	}
        2:  306:	state = ssh->state;
        2:  307:	state->connection_in = fd_in;
        2:  308:	state->connection_out = fd_out;
        2:  309:	if ((r = cipher_init(&state->send_context, none,
        2:  310:	    (const u_char *)"", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||
        2:  311:	    (r = cipher_init(&state->receive_context, none,
        -:  312:	    (const u_char *)"", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {
    #####:  313:		error("%s: cipher_init failed: %s", __func__, ssh_err(r));
    #####:  314:		free(ssh); /* XXX need ssh_free_session_state? */
    #####:  315:		return NULL;
        -:  316:	}
        2:  317:	state->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;
        2:  318:	deattack_init(&state->deattack);
        -:  319:	/*
        -:  320:	 * Cache the IP address of the remote connection for use in error
        -:  321:	 * messages that might be generated after the connection has closed.
        -:  322:	 */
        2:  323:	(void)ssh_remote_ipaddr(ssh);
        2:  324:	return ssh;
        -:  325:}
        -:  326:
        -:  327:void
        2:  328:ssh_packet_set_timeout(struct ssh *ssh, int timeout, int count)
        -:  329:{
        2:  330:	struct session_state *state = ssh->state;
        -:  331:
        2:  332:	if (timeout <= 0 || count <= 0) {
        2:  333:		state->packet_timeout_ms = -1;
        4:  334:		return;
        -:  335:	}
    #####:  336:	if ((INT_MAX / 1000) / count < timeout)
    #####:  337:		state->packet_timeout_ms = INT_MAX;
        -:  338:	else
    #####:  339:		state->packet_timeout_ms = timeout * count * 1000;
        -:  340:}
        -:  341:
        -:  342:void
    #####:  343:ssh_packet_set_mux(struct ssh *ssh)
        -:  344:{
    #####:  345:	ssh->state->mux = 1;
    #####:  346:	ssh->state->rekeying = 0;
    #####:  347:}
        -:  348:
        -:  349:int
        2:  350:ssh_packet_get_mux(struct ssh *ssh)
        -:  351:{
        2:  352:	return ssh->state->mux;
        -:  353:}
        -:  354:
        -:  355:int
    #####:  356:ssh_packet_stop_discard(struct ssh *ssh)
        -:  357:{
    #####:  358:	struct session_state *state = ssh->state;
        -:  359:	int r;
        -:  360:
    #####:  361:	if (state->packet_discard_mac) {
        -:  362:		char buf[1024];
    #####:  363:		size_t dlen = PACKET_MAX_SIZE;
        -:  364:
    #####:  365:		if (dlen > state->packet_discard_mac_already)
    #####:  366:			dlen -= state->packet_discard_mac_already;
    #####:  367:		memset(buf, 'a', sizeof(buf));
    #####:  368:		while (sshbuf_len(state->incoming_packet) < dlen)
    #####:  369:			if ((r = sshbuf_put(state->incoming_packet, buf,
        -:  370:			    sizeof(buf))) != 0)
    #####:  371:				return r;
    #####:  372:		(void) mac_compute(state->packet_discard_mac,
        -:  373:		    state->p_read.seqnr,
    #####:  374:		    sshbuf_ptr(state->incoming_packet), dlen,
        -:  375:		    NULL, 0);
        -:  376:	}
    #####:  377:	logit("Finished discarding for %.200s port %d",
        -:  378:	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
    #####:  379:	return SSH_ERR_MAC_INVALID;
        -:  380:}
        -:  381:
        -:  382:static int
    #####:  383:ssh_packet_start_discard(struct ssh *ssh, struct sshenc *enc,
        -:  384:    struct sshmac *mac, size_t mac_already, u_int discard)
        -:  385:{
    #####:  386:	struct session_state *state = ssh->state;
        -:  387:	int r;
        -:  388:
    #####:  389:	if (enc == NULL || !cipher_is_cbc(enc->cipher) || (mac && mac->etm)) {
    #####:  390:		if ((r = sshpkt_disconnect(ssh, "Packet corrupt")) != 0)
    #####:  391:			return r;
    #####:  392:		return SSH_ERR_MAC_INVALID;
        -:  393:	}
        -:  394:	/*
        -:  395:	 * Record number of bytes over which the mac has already
        -:  396:	 * been computed in order to minimize timing attacks.
        -:  397:	 */
    #####:  398:	if (mac && mac->enabled) {
    #####:  399:		state->packet_discard_mac = mac;
    #####:  400:		state->packet_discard_mac_already = mac_already;
        -:  401:	}
    #####:  402:	if (sshbuf_len(state->input) >= discard)
    #####:  403:		return ssh_packet_stop_discard(ssh);
    #####:  404:	state->packet_discard = discard - sshbuf_len(state->input);
    #####:  405:	return 0;
        -:  406:}
        -:  407:
        -:  408:/* Returns 1 if remote host is connected via socket, 0 if not. */
        -:  409:
        -:  410:int
        8:  411:ssh_packet_connection_is_on_socket(struct ssh *ssh)
        -:  412:{
        8:  413:	struct session_state *state = ssh->state;
        -:  414:	struct sockaddr_storage from, to;
        -:  415:	socklen_t fromlen, tolen;
        -:  416:
        8:  417:	if (state->connection_in == -1 || state->connection_out == -1)
    #####:  418:		return 0;
        -:  419:
        -:  420:	/* filedescriptors in and out are the same, so it's a socket */
        8:  421:	if (state->connection_in == state->connection_out)
        8:  422:		return 1;
    #####:  423:	fromlen = sizeof(from);
    #####:  424:	memset(&from, 0, sizeof(from));
    #####:  425:	if (getpeername(state->connection_in, (struct sockaddr *)&from,
        -:  426:	    &fromlen) < 0)
    #####:  427:		return 0;
    #####:  428:	tolen = sizeof(to);
    #####:  429:	memset(&to, 0, sizeof(to));
    #####:  430:	if (getpeername(state->connection_out, (struct sockaddr *)&to,
        -:  431:	    &tolen) < 0)
    #####:  432:		return 0;
    #####:  433:	if (fromlen != tolen || memcmp(&from, &to, fromlen) != 0)
    #####:  434:		return 0;
    #####:  435:	if (from.ss_family != AF_INET && from.ss_family != AF_INET6)
    #####:  436:		return 0;
    #####:  437:	return 1;
        -:  438:}
        -:  439:
        -:  440:void
        2:  441:ssh_packet_get_bytes(struct ssh *ssh, u_int64_t *ibytes, u_int64_t *obytes)
        -:  442:{
        2:  443:	if (ibytes)
        2:  444:		*ibytes = ssh->state->p_read.bytes;
        2:  445:	if (obytes)
        2:  446:		*obytes = ssh->state->p_send.bytes;
        2:  447:}
        -:  448:
        -:  449:int
        2:  450:ssh_packet_connection_af(struct ssh *ssh)
        -:  451:{
        -:  452:	struct sockaddr_storage to;
        2:  453:	socklen_t tolen = sizeof(to);
        -:  454:
        2:  455:	memset(&to, 0, sizeof(to));
        2:  456:	if (getsockname(ssh->state->connection_out, (struct sockaddr *)&to,
        -:  457:	    &tolen) < 0)
    #####:  458:		return 0;
        -:  459:#ifdef IPV4_IN_IPV6
        2:  460:	if (to.ss_family == AF_INET6 &&
    #####:  461:	    IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)&to)->sin6_addr))
    #####:  462:		return AF_INET;
        -:  463:#endif
        2:  464:	return to.ss_family;
        -:  465:}
        -:  466:
        -:  467:/* Sets the connection into non-blocking mode. */
        -:  468:
        -:  469:void
        2:  470:ssh_packet_set_nonblocking(struct ssh *ssh)
        -:  471:{
        -:  472:	/* Set the socket into non-blocking mode. */
        2:  473:	set_nonblock(ssh->state->connection_in);
        -:  474:
        2:  475:	if (ssh->state->connection_out != ssh->state->connection_in)
    #####:  476:		set_nonblock(ssh->state->connection_out);
        2:  477:}
        -:  478:
        -:  479:/* Returns the socket used for reading. */
        -:  480:
        -:  481:int
        4:  482:ssh_packet_get_connection_in(struct ssh *ssh)
        -:  483:{
        4:  484:	return ssh->state->connection_in;
        -:  485:}
        -:  486:
        -:  487:/* Returns the descriptor used for writing. */
        -:  488:
        -:  489:int
        4:  490:ssh_packet_get_connection_out(struct ssh *ssh)
        -:  491:{
        4:  492:	return ssh->state->connection_out;
        -:  493:}
        -:  494:
        -:  495:/*
        -:  496: * Returns the IP-address of the remote host as a string.  The returned
        -:  497: * string must not be freed.
        -:  498: */
        -:  499:
        -:  500:const char *
        6:  501:ssh_remote_ipaddr(struct ssh *ssh)
        -:  502:{
        6:  503:	const int sock = ssh->state->connection_in;
        -:  504:
        -:  505:	/* Check whether we have cached the ipaddr. */
        6:  506:	if (ssh->remote_ipaddr == NULL) {
        2:  507:		if (ssh_packet_connection_is_on_socket(ssh)) {
        2:  508:			ssh->remote_ipaddr = get_peer_ipaddr(sock);
        2:  509:			ssh->remote_port = get_peer_port(sock);
        2:  510:			ssh->local_ipaddr = get_local_ipaddr(sock);
        2:  511:			ssh->local_port = get_local_port(sock);
        -:  512:		} else {
    #####:  513:			ssh->remote_ipaddr = strdup("UNKNOWN");
    #####:  514:			ssh->remote_port = 65535;
    #####:  515:			ssh->local_ipaddr = strdup("UNKNOWN");
    #####:  516:			ssh->local_port = 65535;
        -:  517:		}
        -:  518:	}
        6:  519:	return ssh->remote_ipaddr;
        -:  520:}
        -:  521:
        -:  522:/* Returns the port number of the remote host. */
        -:  523:
        -:  524:int
        2:  525:ssh_remote_port(struct ssh *ssh)
        -:  526:{
        2:  527:	(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */
        2:  528:	return ssh->remote_port;
        -:  529:}
        -:  530:
        -:  531:/*
        -:  532: * Returns the IP-address of the local host as a string.  The returned
        -:  533: * string must not be freed.
        -:  534: */
        -:  535:
        -:  536:const char *
    #####:  537:ssh_local_ipaddr(struct ssh *ssh)
        -:  538:{
    #####:  539:	(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */
    #####:  540:	return ssh->local_ipaddr;
        -:  541:}
        -:  542:
        -:  543:/* Returns the port number of the local host. */
        -:  544:
        -:  545:int
    #####:  546:ssh_local_port(struct ssh *ssh)
        -:  547:{
    #####:  548:	(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */
    #####:  549:	return ssh->local_port;
        -:  550:}
        -:  551:
        -:  552:/* Closes the connection and clears and frees internal data structures. */
        -:  553:
        -:  554:void
        2:  555:ssh_packet_close(struct ssh *ssh)
        -:  556:{
        2:  557:	struct session_state *state = ssh->state;
        -:  558:	u_int mode;
        -:  559:
        2:  560:	if (!state->initialized)
        2:  561:		return;
        2:  562:	state->initialized = 0;
        2:  563:	if (state->connection_in == state->connection_out) {
        2:  564:		shutdown(state->connection_out, SHUT_RDWR);
        2:  565:		close(state->connection_out);
        -:  566:	} else {
    #####:  567:		close(state->connection_in);
    #####:  568:		close(state->connection_out);
        -:  569:	}
        2:  570:	sshbuf_free(state->input);
        2:  571:	sshbuf_free(state->output);
        2:  572:	sshbuf_free(state->outgoing_packet);
        2:  573:	sshbuf_free(state->incoming_packet);
        6:  574:	for (mode = 0; mode < MODE_MAX; mode++)
        4:  575:		kex_free_newkeys(state->newkeys[mode]);
        2:  576:	if (state->compression_buffer) {
    #####:  577:		sshbuf_free(state->compression_buffer);
    #####:  578:		if (state->compression_out_started) {
    #####:  579:			z_streamp stream = &state->compression_out_stream;
    #####:  580:			debug("compress outgoing: "
        -:  581:			    "raw data %llu, compressed %llu, factor %.2f",
    #####:  582:				(unsigned long long)stream->total_in,
    #####:  583:				(unsigned long long)stream->total_out,
    #####:  584:				stream->total_in == 0 ? 0.0 :
    #####:  585:				(double) stream->total_out / stream->total_in);
    #####:  586:			if (state->compression_out_failures == 0)
    #####:  587:				deflateEnd(stream);
        -:  588:		}
    #####:  589:		if (state->compression_in_started) {
    #####:  590:			z_streamp stream = &state->compression_out_stream;
    #####:  591:			debug("compress incoming: "
        -:  592:			    "raw data %llu, compressed %llu, factor %.2f",
    #####:  593:			    (unsigned long long)stream->total_out,
    #####:  594:			    (unsigned long long)stream->total_in,
    #####:  595:			    stream->total_out == 0 ? 0.0 :
    #####:  596:			    (double) stream->total_in / stream->total_out);
    #####:  597:			if (state->compression_in_failures == 0)
    #####:  598:				inflateEnd(stream);
        -:  599:		}
        -:  600:	}
        2:  601:	cipher_free(state->send_context);
        2:  602:	cipher_free(state->receive_context);
        2:  603:	state->send_context = state->receive_context = NULL;
        2:  604:	free(ssh->remote_ipaddr);
        2:  605:	ssh->remote_ipaddr = NULL;
        2:  606:	free(ssh->state);
        2:  607:	ssh->state = NULL;
        -:  608:}
        -:  609:
        -:  610:/* Sets remote side protocol flags. */
        -:  611:
        -:  612:void
    #####:  613:ssh_packet_set_protocol_flags(struct ssh *ssh, u_int protocol_flags)
        -:  614:{
    #####:  615:	ssh->state->remote_protocol_flags = protocol_flags;
    #####:  616:}
        -:  617:
        -:  618:/* Returns the remote protocol flags set earlier by the above function. */
        -:  619:
        -:  620:u_int
    #####:  621:ssh_packet_get_protocol_flags(struct ssh *ssh)
        -:  622:{
    #####:  623:	return ssh->state->remote_protocol_flags;
        -:  624:}
        -:  625:
        -:  626:/*
        -:  627: * Starts packet compression from the next packet on in both directions.
        -:  628: * Level is compression level 1 (fastest) - 9 (slow, best) as in gzip.
        -:  629: */
        -:  630:
        -:  631:static int
    #####:  632:ssh_packet_init_compression(struct ssh *ssh)
        -:  633:{
    #####:  634:	if (!ssh->state->compression_buffer &&
    #####:  635:	   ((ssh->state->compression_buffer = sshbuf_new()) == NULL))
    #####:  636:		return SSH_ERR_ALLOC_FAIL;
    #####:  637:	return 0;
        -:  638:}
        -:  639:
        -:  640:static int
    #####:  641:start_compression_out(struct ssh *ssh, int level)
        -:  642:{
    #####:  643:	if (level < 1 || level > 9)
    #####:  644:		return SSH_ERR_INVALID_ARGUMENT;
    #####:  645:	debug("Enabling compression at level %d.", level);
    #####:  646:	if (ssh->state->compression_out_started == 1)
    #####:  647:		deflateEnd(&ssh->state->compression_out_stream);
    #####:  648:	switch (deflateInit(&ssh->state->compression_out_stream, level)) {
        -:  649:	case Z_OK:
    #####:  650:		ssh->state->compression_out_started = 1;
    #####:  651:		break;
        -:  652:	case Z_MEM_ERROR:
    #####:  653:		return SSH_ERR_ALLOC_FAIL;
        -:  654:	default:
    #####:  655:		return SSH_ERR_INTERNAL_ERROR;
        -:  656:	}
    #####:  657:	return 0;
        -:  658:}
        -:  659:
        -:  660:static int
    #####:  661:start_compression_in(struct ssh *ssh)
        -:  662:{
    #####:  663:	if (ssh->state->compression_in_started == 1)
    #####:  664:		inflateEnd(&ssh->state->compression_in_stream);
    #####:  665:	switch (inflateInit(&ssh->state->compression_in_stream)) {
        -:  666:	case Z_OK:
    #####:  667:		ssh->state->compression_in_started = 1;
    #####:  668:		break;
        -:  669:	case Z_MEM_ERROR:
    #####:  670:		return SSH_ERR_ALLOC_FAIL;
        -:  671:	default:
    #####:  672:		return SSH_ERR_INTERNAL_ERROR;
        -:  673:	}
    #####:  674:	return 0;
        -:  675:}
        -:  676:
        -:  677:int
    #####:  678:ssh_packet_start_compression(struct ssh *ssh, int level)
        -:  679:{
        -:  680:	int r;
        -:  681:
    #####:  682:	if (ssh->state->packet_compression && !compat20)
    #####:  683:		return SSH_ERR_INTERNAL_ERROR;
    #####:  684:	ssh->state->packet_compression = 1;
    #####:  685:	if ((r = ssh_packet_init_compression(ssh)) != 0 ||
    #####:  686:	    (r = start_compression_in(ssh)) != 0 ||
        -:  687:	    (r = start_compression_out(ssh, level)) != 0)
    #####:  688:		return r;
    #####:  689:	return 0;
        -:  690:}
        -:  691:
        -:  692:/* XXX remove need for separate compression buffer */
        -:  693:static int
    #####:  694:compress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)
        -:  695:{
        -:  696:	u_char buf[4096];
        -:  697:	int r, status;
        -:  698:
    #####:  699:	if (ssh->state->compression_out_started != 1)
    #####:  700:		return SSH_ERR_INTERNAL_ERROR;
        -:  701:
        -:  702:	/* This case is not handled below. */
    #####:  703:	if (sshbuf_len(in) == 0)
    #####:  704:		return 0;
        -:  705:
        -:  706:	/* Input is the contents of the input buffer. */
    #####:  707:	if ((ssh->state->compression_out_stream.next_in =
    #####:  708:	    sshbuf_mutable_ptr(in)) == NULL)
    #####:  709:		return SSH_ERR_INTERNAL_ERROR;
    #####:  710:	ssh->state->compression_out_stream.avail_in = sshbuf_len(in);
        -:  711:
        -:  712:	/* Loop compressing until deflate() returns with avail_out != 0. */
        -:  713:	do {
        -:  714:		/* Set up fixed-size output buffer. */
    #####:  715:		ssh->state->compression_out_stream.next_out = buf;
    #####:  716:		ssh->state->compression_out_stream.avail_out = sizeof(buf);
        -:  717:
        -:  718:		/* Compress as much data into the buffer as possible. */
    #####:  719:		status = deflate(&ssh->state->compression_out_stream,
        -:  720:		    Z_PARTIAL_FLUSH);
    #####:  721:		switch (status) {
        -:  722:		case Z_MEM_ERROR:
    #####:  723:			return SSH_ERR_ALLOC_FAIL;
        -:  724:		case Z_OK:
        -:  725:			/* Append compressed data to output_buffer. */
    #####:  726:			if ((r = sshbuf_put(out, buf, sizeof(buf) -
    #####:  727:			    ssh->state->compression_out_stream.avail_out)) != 0)
    #####:  728:				return r;
    #####:  729:			break;
        -:  730:		case Z_STREAM_ERROR:
        -:  731:		default:
    #####:  732:			ssh->state->compression_out_failures++;
    #####:  733:			return SSH_ERR_INVALID_FORMAT;
        -:  734:		}
    #####:  735:	} while (ssh->state->compression_out_stream.avail_out == 0);
    #####:  736:	return 0;
        -:  737:}
        -:  738:
        -:  739:static int
    #####:  740:uncompress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)
        -:  741:{
        -:  742:	u_char buf[4096];
        -:  743:	int r, status;
        -:  744:
    #####:  745:	if (ssh->state->compression_in_started != 1)
    #####:  746:		return SSH_ERR_INTERNAL_ERROR;
        -:  747:
    #####:  748:	if ((ssh->state->compression_in_stream.next_in =
    #####:  749:	    sshbuf_mutable_ptr(in)) == NULL)
    #####:  750:		return SSH_ERR_INTERNAL_ERROR;
    #####:  751:	ssh->state->compression_in_stream.avail_in = sshbuf_len(in);
        -:  752:
        -:  753:	for (;;) {
        -:  754:		/* Set up fixed-size output buffer. */
    #####:  755:		ssh->state->compression_in_stream.next_out = buf;
    #####:  756:		ssh->state->compression_in_stream.avail_out = sizeof(buf);
        -:  757:
    #####:  758:		status = inflate(&ssh->state->compression_in_stream,
        -:  759:		    Z_PARTIAL_FLUSH);
    #####:  760:		switch (status) {
        -:  761:		case Z_OK:
    #####:  762:			if ((r = sshbuf_put(out, buf, sizeof(buf) -
    #####:  763:			    ssh->state->compression_in_stream.avail_out)) != 0)
    #####:  764:				return r;
    #####:  765:			break;
        -:  766:		case Z_BUF_ERROR:
        -:  767:			/*
        -:  768:			 * Comments in zlib.h say that we should keep calling
        -:  769:			 * inflate() until we get an error.  This appears to
        -:  770:			 * be the error that we get.
        -:  771:			 */
    #####:  772:			return 0;
        -:  773:		case Z_DATA_ERROR:
    #####:  774:			return SSH_ERR_INVALID_FORMAT;
        -:  775:		case Z_MEM_ERROR:
    #####:  776:			return SSH_ERR_ALLOC_FAIL;
        -:  777:		case Z_STREAM_ERROR:
        -:  778:		default:
    #####:  779:			ssh->state->compression_in_failures++;
    #####:  780:			return SSH_ERR_INTERNAL_ERROR;
        -:  781:		}
    #####:  782:	}
        -:  783:	/* NOTREACHED */
        -:  784:}
        -:  785:
        -:  786:/*
        -:  787: * Causes any further packets to be encrypted using the given key.  The same
        -:  788: * key is used for both sending and reception.  However, both directions are
        -:  789: * encrypted independently of each other.
        -:  790: */
        -:  791:
        -:  792:void
    #####:  793:ssh_packet_set_encryption_key(struct ssh *ssh, const u_char *key, u_int keylen, int number)
        -:  794:{
        -:  795:#ifndef WITH_SSH1
    #####:  796:	fatal("no SSH protocol 1 support");
        -:  797:#else /* WITH_SSH1 */
        -:  798:	struct session_state *state = ssh->state;
        -:  799:	const struct sshcipher *cipher = cipher_by_number(number);
        -:  800:	int r;
        -:  801:	const char *wmsg;
        -:  802:
        -:  803:	if (cipher == NULL)
        -:  804:		fatal("%s: unknown cipher number %d", __func__, number);
        -:  805:	if (keylen < 20)
        -:  806:		fatal("%s: keylen too small: %d", __func__, keylen);
        -:  807:	if (keylen > SSH_SESSION_KEY_LENGTH)
        -:  808:		fatal("%s: keylen too big: %d", __func__, keylen);
        -:  809:	memcpy(state->ssh1_key, key, keylen);
        -:  810:	state->ssh1_keylen = keylen;
        -:  811:	if ((r = cipher_init(&state->send_context, cipher, key, keylen,
        -:  812:	    NULL, 0, CIPHER_ENCRYPT)) != 0 ||
        -:  813:	    (r = cipher_init(&state->receive_context, cipher, key, keylen,
        -:  814:	    NULL, 0, CIPHER_DECRYPT) != 0))
        -:  815:		fatal("%s: cipher_init failed: %s", __func__, ssh_err(r));
        -:  816:	if (!state->cipher_warning_done &&
        -:  817:	    ((wmsg = cipher_warning_message(state->send_context)) != NULL ||
        -:  818:	    (wmsg = cipher_warning_message(state->send_context)) != NULL)) {
        -:  819:		error("Warning: %s", wmsg);
        -:  820:		state->cipher_warning_done = 1;
        -:  821:	}
        -:  822:#endif /* WITH_SSH1 */
        -:  823:}
        -:  824:
        -:  825:/*
        -:  826: * Finalizes and sends the packet.  If the encryption key has been set,
        -:  827: * encrypts the packet before sending.
        -:  828: */
        -:  829:
        -:  830:int
    #####:  831:ssh_packet_send1(struct ssh *ssh)
        -:  832:{
    #####:  833:	struct session_state *state = ssh->state;
        -:  834:	u_char buf[8], *cp;
        -:  835:	int r, padding, len;
        -:  836:	u_int checksum;
        -:  837:
        -:  838:	/*
        -:  839:	 * If using packet compression, compress the payload of the outgoing
        -:  840:	 * packet.
        -:  841:	 */
    #####:  842:	if (state->packet_compression) {
    #####:  843:		sshbuf_reset(state->compression_buffer);
        -:  844:		/* Skip padding. */
    #####:  845:		if ((r = sshbuf_consume(state->outgoing_packet, 8)) != 0)
    #####:  846:			goto out;
        -:  847:		/* padding */
    #####:  848:		if ((r = sshbuf_put(state->compression_buffer,
        -:  849:		    "\0\0\0\0\0\0\0\0", 8)) != 0)
    #####:  850:			goto out;
    #####:  851:		if ((r = compress_buffer(ssh, state->outgoing_packet,
        -:  852:		    state->compression_buffer)) != 0)
    #####:  853:			goto out;
    #####:  854:		sshbuf_reset(state->outgoing_packet);
    #####:  855:                if ((r = sshbuf_putb(state->outgoing_packet,
    #####:  856:                    state->compression_buffer)) != 0)
    #####:  857:			goto out;
        -:  858:	}
        -:  859:	/* Compute packet length without padding (add checksum, remove padding). */
    #####:  860:	len = sshbuf_len(state->outgoing_packet) + 4 - 8;
        -:  861:
        -:  862:	/* Insert padding. Initialized to zero in packet_start1() */
    #####:  863:	padding = 8 - len % 8;
    #####:  864:	if (!cipher_ctx_is_plaintext(state->send_context)) {
    #####:  865:		cp = sshbuf_mutable_ptr(state->outgoing_packet);
    #####:  866:		if (cp == NULL) {
    #####:  867:			r = SSH_ERR_INTERNAL_ERROR;
    #####:  868:			goto out;
        -:  869:		}
    #####:  870:		arc4random_buf(cp + 8 - padding, padding);
        -:  871:	}
    #####:  872:	if ((r = sshbuf_consume(state->outgoing_packet, 8 - padding)) != 0)
    #####:  873:		goto out;
        -:  874:
        -:  875:	/* Add check bytes. */
    #####:  876:	checksum = ssh_crc32(sshbuf_ptr(state->outgoing_packet),
    #####:  877:	    sshbuf_len(state->outgoing_packet));
    #####:  878:	POKE_U32(buf, checksum);
    #####:  879:	if ((r = sshbuf_put(state->outgoing_packet, buf, 4)) != 0)
    #####:  880:		goto out;
        -:  881:
        -:  882:#ifdef PACKET_DEBUG
        -:  883:	fprintf(stderr, "packet_send plain: ");
        -:  884:	sshbuf_dump(state->outgoing_packet, stderr);
        -:  885:#endif
        -:  886:
        -:  887:	/* Append to output. */
    #####:  888:	POKE_U32(buf, len);
    #####:  889:	if ((r = sshbuf_put(state->output, buf, 4)) != 0)
    #####:  890:		goto out;
    #####:  891:	if ((r = sshbuf_reserve(state->output,
    #####:  892:	    sshbuf_len(state->outgoing_packet), &cp)) != 0)
    #####:  893:		goto out;
    #####:  894:	if ((r = cipher_crypt(state->send_context, 0, cp,
    #####:  895:	    sshbuf_ptr(state->outgoing_packet),
    #####:  896:	    sshbuf_len(state->outgoing_packet), 0, 0)) != 0)
    #####:  897:		goto out;
        -:  898:
        -:  899:#ifdef PACKET_DEBUG
        -:  900:	fprintf(stderr, "encrypted: ");
        -:  901:	sshbuf_dump(state->output, stderr);
        -:  902:#endif
    #####:  903:	state->p_send.packets++;
    #####:  904:	state->p_send.bytes += len +
    #####:  905:	    sshbuf_len(state->outgoing_packet);
    #####:  906:	sshbuf_reset(state->outgoing_packet);
        -:  907:
        -:  908:	/*
        -:  909:	 * Note that the packet is now only buffered in output.  It won't be
        -:  910:	 * actually sent until ssh_packet_write_wait or ssh_packet_write_poll
        -:  911:	 * is called.
        -:  912:	 */
    #####:  913:	r = 0;
        -:  914: out:
    #####:  915:	return r;
        -:  916:}
        -:  917:
        -:  918:int
        4:  919:ssh_set_newkeys(struct ssh *ssh, int mode)
        -:  920:{
        4:  921:	struct session_state *state = ssh->state;
        -:  922:	struct sshenc *enc;
        -:  923:	struct sshmac *mac;
        -:  924:	struct sshcomp *comp;
        -:  925:	struct sshcipher_ctx **ccp;
        -:  926:	struct packet_state *ps;
        -:  927:	u_int64_t *max_blocks;
        -:  928:	const char *wmsg, *dir;
        -:  929:	int r, crypt_type;
        -:  930:
        4:  931:	debug2("set_newkeys: mode %d", mode);
        -:  932:
        4:  933:	if (mode == MODE_OUT) {
        2:  934:		dir = "output";
        2:  935:		ccp = &state->send_context;
        2:  936:		crypt_type = CIPHER_ENCRYPT;
        2:  937:		ps = &state->p_send;
        2:  938:		max_blocks = &state->max_blocks_out;
        -:  939:	} else {
        2:  940:		dir = "input";
        2:  941:		ccp = &state->receive_context;
        2:  942:		crypt_type = CIPHER_DECRYPT;
        2:  943:		ps = &state->p_read;
        2:  944:		max_blocks = &state->max_blocks_in;
        -:  945:	}
        4:  946:	if (state->newkeys[mode] != NULL) {
    #####:  947:		debug("%s: rekeying after %llu %s blocks"
        -:  948:		    " (%llu bytes total)", __func__,
        -:  949:		    (unsigned long long)ps->blocks, dir,
        -:  950:		    (unsigned long long)ps->bytes);
    #####:  951:		cipher_free(*ccp);
    #####:  952:		*ccp = NULL;
    #####:  953:		enc  = &state->newkeys[mode]->enc;
    #####:  954:		mac  = &state->newkeys[mode]->mac;
    #####:  955:		comp = &state->newkeys[mode]->comp;
    #####:  956:		mac_clear(mac);
    #####:  957:		explicit_bzero(enc->iv,  enc->iv_len);
    #####:  958:		explicit_bzero(enc->key, enc->key_len);
    #####:  959:		explicit_bzero(mac->key, mac->key_len);
    #####:  960:		free(enc->name);
    #####:  961:		free(enc->iv);
    #####:  962:		free(enc->key);
    #####:  963:		free(mac->name);
    #####:  964:		free(mac->key);
    #####:  965:		free(comp->name);
    #####:  966:		free(state->newkeys[mode]);
        -:  967:	}
        -:  968:	/* note that both bytes and the seqnr are not reset */
        4:  969:	ps->packets = ps->blocks = 0;
        -:  970:	/* move newkeys from kex to state */
        4:  971:	if ((state->newkeys[mode] = ssh->kex->newkeys[mode]) == NULL)
    #####:  972:		return SSH_ERR_INTERNAL_ERROR;
        4:  973:	ssh->kex->newkeys[mode] = NULL;
        4:  974:	enc  = &state->newkeys[mode]->enc;
        4:  975:	mac  = &state->newkeys[mode]->mac;
        4:  976:	comp = &state->newkeys[mode]->comp;
        4:  977:	if (cipher_authlen(enc->cipher) == 0) {
    #####:  978:		if ((r = mac_init(mac)) != 0)
    #####:  979:			return r;
        -:  980:	}
        4:  981:	mac->enabled = 1;
        -:  982:	DBG(debug("cipher_init_context: %d", mode));
        8:  983:	if ((r = cipher_init(ccp, enc->cipher, enc->key, enc->key_len,
        4:  984:	    enc->iv, enc->iv_len, crypt_type)) != 0)
    #####:  985:		return r;
        8:  986:	if (!state->cipher_warning_done &&
        4:  987:	    (wmsg = cipher_warning_message(*ccp)) != NULL) {
    #####:  988:		error("Warning: %s", wmsg);
    #####:  989:		state->cipher_warning_done = 1;
        -:  990:	}
        -:  991:	/* Deleting the keys does not gain extra security */
        -:  992:	/* explicit_bzero(enc->iv,  enc->block_size);
        -:  993:	   explicit_bzero(enc->key, enc->key_len);
        -:  994:	   explicit_bzero(mac->key, mac->key_len); */
        8:  995:	if ((comp->type == COMP_ZLIB ||
        4:  996:	    (comp->type == COMP_DELAYED &&
    #####:  997:	     state->after_authentication)) && comp->enabled == 0) {
    #####:  998:		if ((r = ssh_packet_init_compression(ssh)) < 0)
    #####:  999:			return r;
    #####: 1000:		if (mode == MODE_OUT) {
    #####: 1001:			if ((r = start_compression_out(ssh, 6)) != 0)
    #####: 1002:				return r;
        -: 1003:		} else {
    #####: 1004:			if ((r = start_compression_in(ssh)) != 0)
    #####: 1005:				return r;
        -: 1006:		}
    #####: 1007:		comp->enabled = 1;
        -: 1008:	}
        -: 1009:	/*
        -: 1010:	 * The 2^(blocksize*2) limit is too expensive for 3DES,
        -: 1011:	 * blowfish, etc, so enforce a 1GB limit for small blocksizes.
        -: 1012:	 */
        4: 1013:	if (enc->block_size >= 16)
    #####: 1014:		*max_blocks = (u_int64_t)1 << (enc->block_size*2);
        -: 1015:	else
        4: 1016:		*max_blocks = ((u_int64_t)1 << 30) / enc->block_size;
        4: 1017:	if (state->rekey_limit)
    #####: 1018:		*max_blocks = MINIMUM(*max_blocks,
        -: 1019:		    state->rekey_limit / enc->block_size);
        4: 1020:	debug("rekey after %llu blocks", (unsigned long long)*max_blocks);
        4: 1021:	return 0;
        -: 1022:}
        -: 1023:
        -: 1024:#define MAX_PACKETS	(1U<<31)
        -: 1025:static int
      210: 1026:ssh_packet_need_rekeying(struct ssh *ssh, u_int outbound_packet_len)
        -: 1027:{
      210: 1028:	struct session_state *state = ssh->state;
        -: 1029:	u_int32_t out_blocks;
        -: 1030:
        -: 1031:	/* XXX client can't cope with rekeying pre-auth */
      210: 1032:	if (!state->after_authentication)
       20: 1033:		return 0;
        -: 1034:
        -: 1035:	/* Haven't keyed yet or KEX in progress. */
      190: 1036:	if (ssh->kex == NULL || ssh_packet_is_rekeying(ssh))
    #####: 1037:		return 0;
        -: 1038:
        -: 1039:	/* Peer can't rekey */
      190: 1040:	if (ssh->compat & SSH_BUG_NOREKEY)
    #####: 1041:		return 0;
        -: 1042:
        -: 1043:	/*
        -: 1044:	 * Permit one packet in or out per rekey - this allows us to
        -: 1045:	 * make progress when rekey limits are very small.
        -: 1046:	 */
      190: 1047:	if (state->p_send.packets == 0 && state->p_read.packets == 0)
    #####: 1048:		return 0;
        -: 1049:
        -: 1050:	/* Time-based rekeying */
      190: 1051:	if (state->rekey_interval != 0 &&
    #####: 1052:	    state->rekey_time + state->rekey_interval <= monotime())
    #####: 1053:		return 1;
        -: 1054:
        -: 1055:	/* Always rekey when MAX_PACKETS sent in either direction */
      380: 1056:	if (state->p_send.packets > MAX_PACKETS ||
      190: 1057:	    state->p_read.packets > MAX_PACKETS)
    #####: 1058:		return 1;
        -: 1059:
        -: 1060:	/* Rekey after (cipher-specific) maxiumum blocks */
      190: 1061:	out_blocks = ROUNDUP(outbound_packet_len,
        -: 1062:	    state->newkeys[MODE_OUT]->enc.block_size);
      570: 1063:	return (state->max_blocks_out &&
      380: 1064:	    (state->p_send.blocks + out_blocks > state->max_blocks_out)) ||
      380: 1065:	    (state->max_blocks_in &&
      190: 1066:	    (state->p_read.blocks > state->max_blocks_in));
        -: 1067:}
        -: 1068:
        -: 1069:/*
        -: 1070: * Delayed compression for SSH2 is enabled after authentication:
        -: 1071: * This happens on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
        -: 1072: * and on the client side after a SSH2_MSG_USERAUTH_SUCCESS is received.
        -: 1073: */
        -: 1074:static int
        2: 1075:ssh_packet_enable_delayed_compress(struct ssh *ssh)
        -: 1076:{
        2: 1077:	struct session_state *state = ssh->state;
        2: 1078:	struct sshcomp *comp = NULL;
        -: 1079:	int r, mode;
        -: 1080:
        -: 1081:	/*
        -: 1082:	 * Remember that we are past the authentication step, so rekeying
        -: 1083:	 * with COMP_DELAYED will turn on compression immediately.
        -: 1084:	 */
        2: 1085:	state->after_authentication = 1;
        6: 1086:	for (mode = 0; mode < MODE_MAX; mode++) {
        -: 1087:		/* protocol error: USERAUTH_SUCCESS received before NEWKEYS */
        4: 1088:		if (state->newkeys[mode] == NULL)
    #####: 1089:			continue;
        4: 1090:		comp = &state->newkeys[mode]->comp;
        4: 1091:		if (comp && !comp->enabled && comp->type == COMP_DELAYED) {
    #####: 1092:			if ((r = ssh_packet_init_compression(ssh)) != 0)
    #####: 1093:				return r;
    #####: 1094:			if (mode == MODE_OUT) {
    #####: 1095:				if ((r = start_compression_out(ssh, 6)) != 0)
    #####: 1096:					return r;
        -: 1097:			} else {
    #####: 1098:				if ((r = start_compression_in(ssh)) != 0)
    #####: 1099:					return r;
        -: 1100:			}
    #####: 1101:			comp->enabled = 1;
        -: 1102:		}
        -: 1103:	}
        2: 1104:	return 0;
        -: 1105:}
        -: 1106:
        -: 1107:/* Used to mute debug logging for noisy packet types */
        -: 1108:int
      218: 1109:ssh_packet_log_type(u_char type)
        -: 1110:{
      218: 1111:	switch (type) {
        -: 1112:	case SSH2_MSG_CHANNEL_DATA:
        -: 1113:	case SSH2_MSG_CHANNEL_EXTENDED_DATA:
        -: 1114:	case SSH2_MSG_CHANNEL_WINDOW_ADJUST:
      164: 1115:		return 0;
        -: 1116:	default:
       54: 1117:		return 1;
        -: 1118:	}
        -: 1119:}
        -: 1120:
        -: 1121:/*
        -: 1122: * Finalize packet in SSH2 format (compress, mac, encrypt, enqueue)
        -: 1123: */
        -: 1124:
        -: 1125://__attribute__((annotate("declassified")))
        -: 1126:int
       92: 1127:ssh_packet_send2_wrapped(struct ssh *ssh)
        -: 1128:{
       92: 1129:	struct session_state *state = ssh->state;
        -: 1130:	u_char type, *cp, macbuf[SSH_DIGEST_MAX_LENGTH];
       92: 1131:	u_char tmp, padlen, pad = 0;
       92: 1132:	u_int authlen = 0, aadlen = 0;
        -: 1133:	u_int len;
       92: 1134:	struct sshenc *enc   = NULL;
       92: 1135:	struct sshmac *mac   = NULL;
       92: 1136:	struct sshcomp *comp = NULL;
        -: 1137:	int r, block_size;
        -: 1138:
       92: 1139:	if (state->newkeys[MODE_OUT] != NULL) {
       86: 1140:		enc  = &state->newkeys[MODE_OUT]->enc;
       86: 1141:		mac  = &state->newkeys[MODE_OUT]->mac;
       86: 1142:		comp = &state->newkeys[MODE_OUT]->comp;
        -: 1143:		/* disable mac for authenticated encryption */
       86: 1144:		if ((authlen = cipher_authlen(enc->cipher)) != 0)
       86: 1145:			mac = NULL;
        -: 1146:	}
       92: 1147:	block_size = enc ? enc->block_size : 8;
       92: 1148:	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;
        -: 1149:
       92: 1150:	type = (sshbuf_ptr(state->outgoing_packet))[5];
       92: 1151:	if (ssh_packet_log_type(type))
       26: 1152:		debug3("send packet: type %u", type);
        -: 1153:#ifdef PACKET_DEBUG
        -: 1154:	fprintf(stderr, "plain:     ");
        -: 1155:	sshbuf_dump(state->outgoing_packet, stderr);
        -: 1156:#endif
        -: 1157:
       92: 1158:	if (comp && comp->enabled) {
    #####: 1159:		len = sshbuf_len(state->outgoing_packet);
        -: 1160:		/* skip header, compress only payload */
    #####: 1161:		if ((r = sshbuf_consume(state->outgoing_packet, 5)) != 0)
    #####: 1162:			goto out;
    #####: 1163:		sshbuf_reset(state->compression_buffer);
    #####: 1164:		if ((r = compress_buffer(ssh, state->outgoing_packet,
        -: 1165:		    state->compression_buffer)) != 0)
    #####: 1166:			goto out;
    #####: 1167:		sshbuf_reset(state->outgoing_packet);
    #####: 1168:		if ((r = sshbuf_put(state->outgoing_packet,
    #####: 1169:		    "\0\0\0\0\0", 5)) != 0 ||
    #####: 1170:		    (r = sshbuf_putb(state->outgoing_packet,
    #####: 1171:		    state->compression_buffer)) != 0)
        -: 1172:			goto out;
        -: 1173:		DBG(debug("compression: raw %d compressed %zd", len,
        -: 1174:		    sshbuf_len(state->outgoing_packet)));
        -: 1175:	}
        -: 1176:
        -: 1177:	/* sizeof (packet_len + pad_len + payload) */
       92: 1178:	len = sshbuf_len(state->outgoing_packet);
        -: 1179:
        -: 1180:	/*
        -: 1181:	 * calc size of padding, alloc space, get random data,
        -: 1182:	 * minimum padding is 4 bytes
        -: 1183:	 */
       92: 1184:	len -= aadlen; /* packet length is not encrypted for EtM modes */
       92: 1185:	padlen = block_size - (len % block_size);
       92: 1186:	if (padlen < 4)
       10: 1187:		padlen += block_size;
       92: 1188:	if (state->extra_pad) {
    #####: 1189:		tmp = state->extra_pad;
    #####: 1190:		state->extra_pad =
    #####: 1191:		    ROUNDUP(state->extra_pad, block_size);
        -: 1192:		/* check if roundup overflowed */
    #####: 1193:		if (state->extra_pad < tmp)
    #####: 1194:			return SSH_ERR_INVALID_ARGUMENT;
    #####: 1195:		tmp = (len + padlen) % state->extra_pad;
        -: 1196:		/* Check whether pad calculation below will underflow */
    #####: 1197:		if (tmp > state->extra_pad)
    #####: 1198:			return SSH_ERR_INVALID_ARGUMENT;
    #####: 1199:		pad = state->extra_pad - tmp;
        -: 1200:		DBG(debug3("%s: adding %d (len %d padlen %d extra_pad %d)",
        -: 1201:		    __func__, pad, len, padlen, state->extra_pad));
    #####: 1202:		tmp = padlen;
    #####: 1203:		padlen += pad;
        -: 1204:		/* Check whether padlen calculation overflowed */
    #####: 1205:		if (padlen < tmp)
    #####: 1206:			return SSH_ERR_INVALID_ARGUMENT; /* overflow */
    #####: 1207:		state->extra_pad = 0;
        -: 1208:	}
       92: 1209:	if ((r = sshbuf_reserve(state->outgoing_packet, padlen, &cp)) != 0)
    #####: 1210:		goto out;
       92: 1211:	if (enc && !cipher_ctx_is_plaintext(state->send_context)) {
        -: 1212:		/* random padding */
       86: 1213:		arc4random_buf(cp, padlen);
        -: 1214:	} else {
        -: 1215:		/* clear padding */
        6: 1216:		explicit_bzero(cp, padlen);
        -: 1217:	}
        -: 1218:	/* sizeof (packet_len + pad_len + payload + padding) */
       92: 1219:	len = sshbuf_len(state->outgoing_packet);
       92: 1220:	cp = sshbuf_mutable_ptr(state->outgoing_packet);
       92: 1221:	if (cp == NULL) {
    #####: 1222:		r = SSH_ERR_INTERNAL_ERROR;
    #####: 1223:		goto out;
        -: 1224:	}
        -: 1225:	/* packet_length includes payload, padding and padding length field */
       92: 1226:	POKE_U32(cp, len - 4);
       92: 1227:	cp[4] = padlen;
        -: 1228:	DBG(debug("send: len %d (includes padlen %d, aadlen %d)",
        -: 1229:	    len, padlen, aadlen));
        -: 1230:
        -: 1231:	/* compute MAC over seqnr and packet(length fields, payload, padding) */
       92: 1232:	if (mac && mac->enabled && !mac->etm) {
    #####: 1233:		if ((r = mac_compute(mac, state->p_send.seqnr,
    #####: 1234:		    sshbuf_ptr(state->outgoing_packet), len,
        -: 1235:		    macbuf, sizeof(macbuf))) != 0)
    #####: 1236:			goto out;
        -: 1237:		DBG(debug("done calc MAC out #%d", state->p_send.seqnr));
        -: 1238:	}
        -: 1239:	/* encrypt packet and append to output buffer. */
       92: 1240:	if ((r = sshbuf_reserve(state->output,
       92: 1241:	    sshbuf_len(state->outgoing_packet) + authlen, &cp)) != 0)
    #####: 1242:		goto out;
      184: 1243:	if ((r = cipher_crypt(state->send_context, state->p_send.seqnr, cp,
       92: 1244:	    sshbuf_ptr(state->outgoing_packet),
        -: 1245:	    len - aadlen, aadlen, authlen)) != 0)
    #####: 1246:		goto out;
        -: 1247:	/* append unencrypted MAC */
       92: 1248:	if (mac && mac->enabled) {
    #####: 1249:		if (mac->etm) {
        -: 1250:			/* EtM: compute mac over aadlen + cipher text */
    #####: 1251:			if ((r = mac_compute(mac, state->p_send.seqnr,
        -: 1252:			    cp, len, macbuf, sizeof(macbuf))) != 0)
    #####: 1253:				goto out;
        -: 1254:			DBG(debug("done calc MAC(EtM) out #%d",
        -: 1255:			    state->p_send.seqnr));
        -: 1256:		}
    #####: 1257:		if ((r = sshbuf_put(state->output, macbuf, mac->mac_len)) != 0)
    #####: 1258:			goto out;
        -: 1259:	}
        -: 1260:#ifdef PACKET_DEBUG
        -: 1261:	fprintf(stderr, "encrypted: ");
        -: 1262:	sshbuf_dump(state->output, stderr);
        -: 1263:#endif
        -: 1264:	/* increment sequence number for outgoing packets */
       92: 1265:	if (++state->p_send.seqnr == 0)
    #####: 1266:		logit("outgoing seqnr wraps around");
       92: 1267:	if (++state->p_send.packets == 0)
    #####: 1268:		if (!(ssh->compat & SSH_BUG_NOREKEY))
    #####: 1269:			return SSH_ERR_NEED_REKEY;
       92: 1270:	state->p_send.blocks += len / block_size;
       92: 1271:	state->p_send.bytes += len;
       92: 1272:	sshbuf_reset(state->outgoing_packet);
        -: 1273:
       92: 1274:	if (type == SSH2_MSG_NEWKEYS)
        2: 1275:		r = ssh_set_newkeys(ssh, MODE_OUT);
       90: 1276:	else if (type == SSH2_MSG_USERAUTH_SUCCESS && state->server_side)
    #####: 1277:		r = ssh_packet_enable_delayed_compress(ssh);
        -: 1278:	else
       90: 1279:		r = 0;
        -: 1280: out:
       92: 1281:	return r;
        -: 1282:}
        -: 1283:
        -: 1284:/* returns non-zero if the specified packet type is usec by KEX */
        -: 1285:static int
       98: 1286:ssh_packet_type_is_kex(u_char type)
        -: 1287:{
       98: 1288:	return
       98: 1289:	    type >= SSH2_MSG_TRANSPORT_MIN &&
       16: 1290:	    type <= SSH2_MSG_TRANSPORT_MAX &&
       14: 1291:	    type != SSH2_MSG_SERVICE_REQUEST &&
      112: 1292:	    type != SSH2_MSG_SERVICE_ACCEPT &&
        -: 1293:	    type != SSH2_MSG_EXT_INFO;
        -: 1294:}
        -: 1295:
        -: 1296://__attribute__((annotate("declassified")))
        -: 1297:int
       92: 1298:ssh_packet_send2(struct ssh *ssh)
        -: 1299:{
       92: 1300:	struct session_state *state = ssh->state;
        -: 1301:	struct packet *p;
        -: 1302:	u_char type;
        -: 1303:	int r, need_rekey;
        -: 1304:
       92: 1305:	if (sshbuf_len(state->outgoing_packet) < 6)
    #####: 1306:		return SSH_ERR_INTERNAL_ERROR;
       92: 1307:	type = sshbuf_ptr(state->outgoing_packet)[5];
      176: 1308:	need_rekey = !ssh_packet_type_is_kex(type) &&
       84: 1309:	    ssh_packet_need_rekeying(ssh, sshbuf_len(state->outgoing_packet));
        -: 1310:
        -: 1311:	/*
        -: 1312:	 * During rekeying we can only send key exchange messages.
        -: 1313:	 * Queue everything else.
        -: 1314:	 */
       92: 1315:	if ((need_rekey || state->rekeying) && !ssh_packet_type_is_kex(type)) {
    #####: 1316:		if (need_rekey)
    #####: 1317:			debug3("%s: rekex triggered", __func__);
    #####: 1318:		debug("enqueue packet: %u", type);
    #####: 1319:		p = calloc(1, sizeof(*p));
    #####: 1320:		if (p == NULL)
    #####: 1321:			return SSH_ERR_ALLOC_FAIL;
    #####: 1322:		p->type = type;
    #####: 1323:		p->payload = state->outgoing_packet;
    #####: 1324:		TAILQ_INSERT_TAIL(&state->outgoing, p, next);
    #####: 1325:		state->outgoing_packet = sshbuf_new();
    #####: 1326:		if (state->outgoing_packet == NULL)
    #####: 1327:			return SSH_ERR_ALLOC_FAIL;
    #####: 1328:		if (need_rekey) {
        -: 1329:			/*
        -: 1330:			 * This packet triggered a rekey, so send the
        -: 1331:			 * KEXINIT now.
        -: 1332:			 * NB. reenters this function via kex_start_rekex().
        -: 1333:			 */
    #####: 1334:			return kex_start_rekex(ssh);
        -: 1335:		}
    #####: 1336:		return 0;
        -: 1337:	}
        -: 1338:
        -: 1339:	/* rekeying starts with sending KEXINIT */
       92: 1340:	if (type == SSH2_MSG_KEXINIT)
        2: 1341:		state->rekeying = 1;
        -: 1342:
       92: 1343:	if ((r = ssh_packet_send2_wrapped(ssh)) != 0)
    #####: 1344:		return r;
        -: 1345:
        -: 1346:	/* after a NEWKEYS message we can send the complete queue */
       92: 1347:	if (type == SSH2_MSG_NEWKEYS) {
        2: 1348:		state->rekeying = 0;
        2: 1349:		state->rekey_time = monotime();
        4: 1350:		while ((p = TAILQ_FIRST(&state->outgoing))) {
    #####: 1351:			type = p->type;
        -: 1352:			/*
        -: 1353:			 * If this packet triggers a rekex, then skip the
        -: 1354:			 * remaining packets in the queue for now.
        -: 1355:			 * NB. re-enters this function via kex_start_rekex.
        -: 1356:			 */
    #####: 1357:			if (ssh_packet_need_rekeying(ssh,
    #####: 1358:			    sshbuf_len(p->payload))) {
    #####: 1359:				debug3("%s: queued packet triggered rekex",
        -: 1360:				    __func__);
    #####: 1361:				return kex_start_rekex(ssh);
        -: 1362:			}
    #####: 1363:			debug("dequeue packet: %u", type);
    #####: 1364:			sshbuf_free(state->outgoing_packet);
    #####: 1365:			state->outgoing_packet = p->payload;
    #####: 1366:			TAILQ_REMOVE(&state->outgoing, p, next);
    #####: 1367:			memset(p, 0, sizeof(*p));
    #####: 1368:			free(p);
    #####: 1369:			if ((r = ssh_packet_send2_wrapped(ssh)) != 0)
    #####: 1370:				return r;
        -: 1371:		}
        -: 1372:	}
       92: 1373:	return 0;
        -: 1374:}
        -: 1375:
        -: 1376:/*
        -: 1377: * Waits until a packet has been received, and returns its type.  Note that
        -: 1378: * no other data is processed until this returns, so this function should not
        -: 1379: * be used during the interactive session.
        -: 1380: */
        -: 1381:
        -: 1382:int
       14: 1383:ssh_packet_read_seqnr(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
        -: 1384:{
       14: 1385:	struct session_state *state = ssh->state;
        -: 1386:	int len, r, ms_remain;
        -: 1387:	fd_set *setp;
        -: 1388:	char buf[8192];
       14: 1389:	struct timeval timeout, start, *timeoutp = NULL;
        -: 1390:
        -: 1391:	DBG(debug("packet_read()"));
        -: 1392:
       14: 1393:	setp = calloc(howmany(state->connection_in + 1,
        -: 1394:	    NFDBITS), sizeof(fd_mask));
       14: 1395:	if (setp == NULL)
    #####: 1396:		return SSH_ERR_ALLOC_FAIL;
        -: 1397:
        -: 1398:	/*
        -: 1399:	 * Since we are blocking, ensure that all written packets have
        -: 1400:	 * been sent.
        -: 1401:	 */
       14: 1402:	if ((r = ssh_packet_write_wait(ssh)) != 0)
    #####: 1403:		goto out;
        -: 1404:
        -: 1405:	/* Stay in the loop until we have received a complete packet. */
        -: 1406:	for (;;) {
        -: 1407:		/* Try to read a packet from the buffer. */
       26: 1408:		r = ssh_packet_read_poll_seqnr(ssh, typep, seqnr_p);
       26: 1409:		if (r != 0)
    #####: 1410:			break;
       26: 1411:		if (!compat20 && (
    #####: 1412:		    *typep == SSH_SMSG_SUCCESS
    #####: 1413:		    || *typep == SSH_SMSG_FAILURE
    #####: 1414:		    || *typep == SSH_CMSG_EOF
    #####: 1415:		    || *typep == SSH_CMSG_EXIT_CONFIRMATION))
    #####: 1416:			if ((r = sshpkt_get_end(ssh)) != 0)
    #####: 1417:				break;
        -: 1418:		/* If we got a packet, return it. */
       26: 1419:		if (*typep != SSH_MSG_NONE)
       14: 1420:			break;
        -: 1421:		/*
        -: 1422:		 * Otherwise, wait for some data to arrive, add it to the
        -: 1423:		 * buffer, and try again.
        -: 1424:		 */
       12: 1425:		memset(setp, 0, howmany(state->connection_in + 1,
        -: 1426:		    NFDBITS) * sizeof(fd_mask));
       12: 1427:		FD_SET(state->connection_in, setp);
        -: 1428:
       12: 1429:		if (state->packet_timeout_ms > 0) {
    #####: 1430:			ms_remain = state->packet_timeout_ms;
    #####: 1431:			timeoutp = &timeout;
        -: 1432:		}
        -: 1433:		/* Wait for some data to arrive. */
        -: 1434:		for (;;) {
       12: 1435:			if (state->packet_timeout_ms != -1) {
    #####: 1436:				ms_to_timeval(&timeout, ms_remain);
    #####: 1437:				gettimeofday(&start, NULL);
        -: 1438:			}
       12: 1439:			if ((r = select(state->connection_in + 1, setp,
        -: 1440:			    NULL, NULL, timeoutp)) >= 0)
       12: 1441:				break;
    #####: 1442:			if (errno != EAGAIN && errno != EINTR &&
    #####: 1443:			    errno != EWOULDBLOCK)
    #####: 1444:				break;
    #####: 1445:			if (state->packet_timeout_ms == -1)
    #####: 1446:				continue;
    #####: 1447:			ms_subtract_diff(&start, &ms_remain);
    #####: 1448:			if (ms_remain <= 0) {
    #####: 1449:				r = 0;
    #####: 1450:				break;
        -: 1451:			}
    #####: 1452:		}
       12: 1453:		if (r == 0)
    #####: 1454:			return SSH_ERR_CONN_TIMEOUT;
        -: 1455:		/* Read data from the socket. */
       12: 1456:		len = read(state->connection_in, buf, sizeof(buf));
       12: 1457:		if (len == 0) {
    #####: 1458:			r = SSH_ERR_CONN_CLOSED;
    #####: 1459:			goto out;
        -: 1460:		}
       12: 1461:		if (len < 0) {
    #####: 1462:			r = SSH_ERR_SYSTEM_ERROR;
    #####: 1463:			goto out;
        -: 1464:		}
        -: 1465:
        -: 1466:		/* Append it to the buffer. */
       12: 1467:		if ((r = ssh_packet_process_incoming(ssh, buf, len)) != 0)
    #####: 1468:			goto out;
       12: 1469:	}
        -: 1470: out:
       14: 1471:	free(setp);
       14: 1472:	return r;
        -: 1473:}
        -: 1474:
        -: 1475:int
    #####: 1476:ssh_packet_read(struct ssh *ssh)
        -: 1477:{
        -: 1478:	u_char type;
        -: 1479:	int r;
        -: 1480:
    #####: 1481:	if ((r = ssh_packet_read_seqnr(ssh, &type, NULL)) != 0)
    #####: 1482:		fatal("%s: %s", __func__, ssh_err(r));
    #####: 1483:	return type;
        -: 1484:}
        -: 1485:
        -: 1486:/*
        -: 1487: * Waits until a packet has been received, verifies that its type matches
        -: 1488: * that given, and gives a fatal error and exits if there is a mismatch.
        -: 1489: */
        -: 1490:
        -: 1491:int
    #####: 1492:ssh_packet_read_expect(struct ssh *ssh, u_int expected_type)
        -: 1493:{
        -: 1494:	int r;
        -: 1495:	u_char type;
        -: 1496:
    #####: 1497:	if ((r = ssh_packet_read_seqnr(ssh, &type, NULL)) != 0)
    #####: 1498:		return r;
    #####: 1499:	if (type != expected_type) {
    #####: 1500:		if ((r = sshpkt_disconnect(ssh,
        -: 1501:		    "Protocol error: expected packet type %d, got %d",
        -: 1502:		    expected_type, type)) != 0)
    #####: 1503:			return r;
    #####: 1504:		return SSH_ERR_PROTOCOL_ERROR;
        -: 1505:	}
    #####: 1506:	return 0;
        -: 1507:}
        -: 1508:
        -: 1509:/* Checks if a full packet is available in the data received so far via
        -: 1510: * packet_process_incoming.  If so, reads the packet; otherwise returns
        -: 1511: * SSH_MSG_NONE.  This does not wait for data from the connection.
        -: 1512: *
        -: 1513: * SSH_MSG_DISCONNECT is handled specially here.  Also,
        -: 1514: * SSH_MSG_IGNORE messages are skipped by this function and are never returned
        -: 1515: * to higher levels.
        -: 1516: */
        -: 1517:
        -: 1518:int
    #####: 1519:ssh_packet_read_poll1(struct ssh *ssh, u_char *typep)
        -: 1520:{
    #####: 1521:	struct session_state *state = ssh->state;
        -: 1522:	u_int len, padded_len;
        -: 1523:	const char *emsg;
        -: 1524:	const u_char *cp;
        -: 1525:	u_char *p;
        -: 1526:	u_int checksum, stored_checksum;
        -: 1527:	int r;
        -: 1528:
    #####: 1529:	*typep = SSH_MSG_NONE;
        -: 1530:
        -: 1531:	/* Check if input size is less than minimum packet size. */
    #####: 1532:	if (sshbuf_len(state->input) < 4 + 8)
    #####: 1533:		return 0;
        -: 1534:	/* Get length of incoming packet. */
    #####: 1535:	len = PEEK_U32(sshbuf_ptr(state->input));
    #####: 1536:	if (len < 1 + 2 + 2 || len > 256 * 1024) {
    #####: 1537:		if ((r = sshpkt_disconnect(ssh, "Bad packet length %u",
        -: 1538:		    len)) != 0)
    #####: 1539:			return r;
    #####: 1540:		return SSH_ERR_CONN_CORRUPT;
        -: 1541:	}
    #####: 1542:	padded_len = (len + 8) & ~7;
        -: 1543:
        -: 1544:	/* Check if the packet has been entirely received. */
    #####: 1545:	if (sshbuf_len(state->input) < 4 + padded_len)
    #####: 1546:		return 0;
        -: 1547:
        -: 1548:	/* The entire packet is in buffer. */
        -: 1549:
        -: 1550:	/* Consume packet length. */
    #####: 1551:	if ((r = sshbuf_consume(state->input, 4)) != 0)
    #####: 1552:		goto out;
        -: 1553:
        -: 1554:	/*
        -: 1555:	 * Cryptographic attack detector for ssh
        -: 1556:	 * (C)1998 CORE-SDI, Buenos Aires Argentina
        -: 1557:	 * Ariel Futoransky(futo@core-sdi.com)
        -: 1558:	 */
    #####: 1559:	if (!cipher_ctx_is_plaintext(state->receive_context)) {
    #####: 1560:		emsg = NULL;
    #####: 1561:		switch (detect_attack(&state->deattack,
    #####: 1562:		    sshbuf_ptr(state->input), padded_len)) {
        -: 1563:		case DEATTACK_OK:
    #####: 1564:			break;
        -: 1565:		case DEATTACK_DETECTED:
    #####: 1566:			emsg = "crc32 compensation attack detected";
    #####: 1567:			break;
        -: 1568:		case DEATTACK_DOS_DETECTED:
    #####: 1569:			emsg = "deattack denial of service detected";
    #####: 1570:			break;
        -: 1571:		default:
    #####: 1572:			emsg = "deattack error";
    #####: 1573:			break;
        -: 1574:		}
    #####: 1575:		if (emsg != NULL) {
    #####: 1576:			error("%s", emsg);
    #####: 1577:			if ((r = sshpkt_disconnect(ssh, "%s", emsg)) != 0 ||
        -: 1578:			    (r = ssh_packet_write_wait(ssh)) != 0)
    #####: 1579:					return r;
    #####: 1580:			return SSH_ERR_CONN_CORRUPT;
        -: 1581:		}
        -: 1582:	}
        -: 1583:
        -: 1584:	/* Decrypt data to incoming_packet. */
    #####: 1585:	sshbuf_reset(state->incoming_packet);
    #####: 1586:	if ((r = sshbuf_reserve(state->incoming_packet, padded_len, &p)) != 0)
    #####: 1587:		goto out;
    #####: 1588:	if ((r = cipher_crypt(state->receive_context, 0, p,
    #####: 1589:	    sshbuf_ptr(state->input), padded_len, 0, 0)) != 0)
    #####: 1590:		goto out;
        -: 1591:
    #####: 1592:	if ((r = sshbuf_consume(state->input, padded_len)) != 0)
    #####: 1593:		goto out;
        -: 1594:
        -: 1595:#ifdef PACKET_DEBUG
        -: 1596:	fprintf(stderr, "read_poll plain: ");
        -: 1597:	sshbuf_dump(state->incoming_packet, stderr);
        -: 1598:#endif
        -: 1599:
        -: 1600:	/* Compute packet checksum. */
    #####: 1601:	checksum = ssh_crc32(sshbuf_ptr(state->incoming_packet),
    #####: 1602:	    sshbuf_len(state->incoming_packet) - 4);
        -: 1603:
        -: 1604:	/* Skip padding. */
    #####: 1605:	if ((r = sshbuf_consume(state->incoming_packet, 8 - len % 8)) != 0)
    #####: 1606:		goto out;
        -: 1607:
        -: 1608:	/* Test check bytes. */
    #####: 1609:	if (len != sshbuf_len(state->incoming_packet)) {
    #####: 1610:		error("%s: len %d != sshbuf_len %zd", __func__,
    #####: 1611:		    len, sshbuf_len(state->incoming_packet));
    #####: 1612:		if ((r = sshpkt_disconnect(ssh, "invalid packet length")) != 0 ||
        -: 1613:		    (r = ssh_packet_write_wait(ssh)) != 0)
    #####: 1614:			return r;
    #####: 1615:		return SSH_ERR_CONN_CORRUPT;
        -: 1616:	}
        -: 1617:
    #####: 1618:	cp = sshbuf_ptr(state->incoming_packet) + len - 4;
    #####: 1619:	stored_checksum = PEEK_U32(cp);
    #####: 1620:	if (checksum != stored_checksum) {
    #####: 1621:		error("Corrupted check bytes on input");
    #####: 1622:		if ((r = sshpkt_disconnect(ssh, "connection corrupted")) != 0 ||
        -: 1623:		    (r = ssh_packet_write_wait(ssh)) != 0)
    #####: 1624:			return r;
    #####: 1625:		return SSH_ERR_CONN_CORRUPT;
        -: 1626:	}
    #####: 1627:	if ((r = sshbuf_consume_end(state->incoming_packet, 4)) < 0)
    #####: 1628:		goto out;
        -: 1629:
    #####: 1630:	if (state->packet_compression) {
    #####: 1631:		sshbuf_reset(state->compression_buffer);
    #####: 1632:		if ((r = uncompress_buffer(ssh, state->incoming_packet,
        -: 1633:		    state->compression_buffer)) != 0)
    #####: 1634:			goto out;
    #####: 1635:		sshbuf_reset(state->incoming_packet);
    #####: 1636:		if ((r = sshbuf_putb(state->incoming_packet,
    #####: 1637:		    state->compression_buffer)) != 0)
    #####: 1638:			goto out;
        -: 1639:	}
    #####: 1640:	state->p_read.packets++;
    #####: 1641:	state->p_read.bytes += padded_len + 4;
    #####: 1642:	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
    #####: 1643:		goto out;
    #####: 1644:	if (*typep < SSH_MSG_MIN || *typep > SSH_MSG_MAX) {
    #####: 1645:		error("Invalid ssh1 packet type: %d", *typep);
    #####: 1646:		if ((r = sshpkt_disconnect(ssh, "invalid packet type")) != 0 ||
        -: 1647:		    (r = ssh_packet_write_wait(ssh)) != 0)
    #####: 1648:			return r;
    #####: 1649:		return SSH_ERR_PROTOCOL_ERROR;
        -: 1650:	}
    #####: 1651:	r = 0;
        -: 1652: out:
    #####: 1653:	return r;
        -: 1654:}
        -: 1655:
        -: 1656:static int
    #####: 1657:ssh_packet_read_poll2_mux(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
        -: 1658:{
    #####: 1659:	struct session_state *state = ssh->state;
        -: 1660:	const u_char *cp;
        -: 1661:	size_t need;
        -: 1662:	int r;
        -: 1663:
    #####: 1664:	if (ssh->kex)
    #####: 1665:		return SSH_ERR_INTERNAL_ERROR;
    #####: 1666:	*typep = SSH_MSG_NONE;
    #####: 1667:	cp = sshbuf_ptr(state->input);
    #####: 1668:	if (state->packlen == 0) {
    #####: 1669:		if (sshbuf_len(state->input) < 4 + 1)
    #####: 1670:			return 0; /* packet is incomplete */
    #####: 1671:		state->packlen = PEEK_U32(cp);
    #####: 1672:		if (state->packlen < 4 + 1 ||
    #####: 1673:		    state->packlen > PACKET_MAX_SIZE)
    #####: 1674:			return SSH_ERR_MESSAGE_INCOMPLETE;
        -: 1675:	}
    #####: 1676:	need = state->packlen + 4;
    #####: 1677:	if (sshbuf_len(state->input) < need)
    #####: 1678:		return 0; /* packet is incomplete */
    #####: 1679:	sshbuf_reset(state->incoming_packet);
    #####: 1680:	if ((r = sshbuf_put(state->incoming_packet, cp + 4,
    #####: 1681:	    state->packlen)) != 0 ||
    #####: 1682:	    (r = sshbuf_consume(state->input, need)) != 0 ||
    #####: 1683:	    (r = sshbuf_get_u8(state->incoming_packet, NULL)) != 0 ||
    #####: 1684:	    (r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
    #####: 1685:		return r;
    #####: 1686:	if (ssh_packet_log_type(*typep))
    #####: 1687:		debug3("%s: type %u", __func__, *typep);
        -: 1688:	/* sshbuf_dump(state->incoming_packet, stderr); */
        -: 1689:	/* reset for next packet */
    #####: 1690:	state->packlen = 0;
    #####: 1691:	return r;
        -: 1692:}
        -: 1693:
        -: 1694:int
      452: 1695:ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
        -: 1696:{
      452: 1697:	struct session_state *state = ssh->state;
        -: 1698:	u_int padlen, need;
        -: 1699:	u_char *cp;
      452: 1700:	u_int maclen, aadlen = 0, authlen = 0, block_size;
      452: 1701:	struct sshenc *enc   = NULL;
      452: 1702:	struct sshmac *mac   = NULL;
      452: 1703:	struct sshcomp *comp = NULL;
        -: 1704:	int r;
        -: 1705:
      452: 1706:	if (state->mux)
    #####: 1707:		return ssh_packet_read_poll2_mux(ssh, typep, seqnr_p);
        -: 1708:
      452: 1709:	*typep = SSH_MSG_NONE;
        -: 1710:
      452: 1711:	if (state->packet_discard)
    #####: 1712:		return 0;
        -: 1713:
      452: 1714:	if (state->newkeys[MODE_IN] != NULL) {
      442: 1715:		enc  = &state->newkeys[MODE_IN]->enc;
      442: 1716:		mac  = &state->newkeys[MODE_IN]->mac;
      442: 1717:		comp = &state->newkeys[MODE_IN]->comp;
        -: 1718:		/* disable mac for authenticated encryption */
      442: 1719:		if ((authlen = cipher_authlen(enc->cipher)) != 0)
      442: 1720:			mac = NULL;
        -: 1721:	}
      452: 1722:	maclen = mac && mac->enabled ? mac->mac_len : 0;
      452: 1723:	block_size = enc ? enc->block_size : 8;
      452: 1724:	aadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;
        -: 1725:
      452: 1726:	if (aadlen && state->packlen == 0) {
      884: 1727:		if (cipher_get_length(state->receive_context,
        -: 1728:		    &state->packlen, state->p_read.seqnr,
      884: 1729:		    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)
      322: 1730:			return 0;
      240: 1731:		if (state->packlen < 1 + 4 ||
      120: 1732:		    state->packlen > PACKET_MAX_SIZE) {
        -: 1733:#ifdef PACKET_DEBUG
        -: 1734:			sshbuf_dump(state->input, stderr);
        -: 1735:#endif
    #####: 1736:			logit("Bad packet length %u.", state->packlen);
    #####: 1737:			if ((r = sshpkt_disconnect(ssh, "Packet corrupt")) != 0)
    #####: 1738:				return r;
    #####: 1739:			return SSH_ERR_CONN_CORRUPT;
        -: 1740:		}
      120: 1741:		sshbuf_reset(state->incoming_packet);
       10: 1742:	} else if (state->packlen == 0) {
        -: 1743:		/*
        -: 1744:		 * check if input size is less than the cipher block size,
        -: 1745:		 * decrypt first block and extract length of incoming packet
        -: 1746:		 */
       10: 1747:		if (sshbuf_len(state->input) < block_size)
        4: 1748:			return 0;
        6: 1749:		sshbuf_reset(state->incoming_packet);
        6: 1750:		if ((r = sshbuf_reserve(state->incoming_packet, block_size,
        -: 1751:		    &cp)) != 0)
    #####: 1752:			goto out;
        6: 1753:		if ((r = cipher_crypt(state->receive_context,
        6: 1754:		    state->p_send.seqnr, cp, sshbuf_ptr(state->input),
        -: 1755:		    block_size, 0, 0)) != 0)
    #####: 1756:			goto out;
        6: 1757:		state->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));
       12: 1758:		if (state->packlen < 1 + 4 ||
        6: 1759:		    state->packlen > PACKET_MAX_SIZE) {
        -: 1760:#ifdef PACKET_DEBUG
        -: 1761:			fprintf(stderr, "input: \n");
        -: 1762:			sshbuf_dump(state->input, stderr);
        -: 1763:			fprintf(stderr, "incoming_packet: \n");
        -: 1764:			sshbuf_dump(state->incoming_packet, stderr);
        -: 1765:#endif
    #####: 1766:			logit("Bad packet length %u.", state->packlen);
    #####: 1767:			return ssh_packet_start_discard(ssh, enc, mac, 0,
        -: 1768:			    PACKET_MAX_SIZE);
        -: 1769:		}
        6: 1770:		if ((r = sshbuf_consume(state->input, block_size)) != 0)
    #####: 1771:			goto out;
        -: 1772:	}
        -: 1773:	DBG(debug("input: packet len %u", state->packlen+4));
        -: 1774:
      126: 1775:	if (aadlen) {
        -: 1776:		/* only the payload is encrypted */
      120: 1777:		need = state->packlen;
        -: 1778:	} else {
        -: 1779:		/*
        -: 1780:		 * the payload size and the payload are encrypted, but we
        -: 1781:		 * have a partial packet of block_size bytes
        -: 1782:		 */
        6: 1783:		need = 4 + state->packlen - block_size;
        -: 1784:	}
        -: 1785:	DBG(debug("partial packet: block %d, need %d, maclen %d, authlen %d,"
        -: 1786:	    " aadlen %d", block_size, need, maclen, authlen, aadlen));
      126: 1787:	if (need % block_size != 0) {
    #####: 1788:		logit("padding error: need %d block %d mod %d",
        -: 1789:		    need, block_size, need % block_size);
    #####: 1790:		return ssh_packet_start_discard(ssh, enc, mac, 0,
        -: 1791:		    PACKET_MAX_SIZE - block_size);
        -: 1792:	}
        -: 1793:	/*
        -: 1794:	 * check if the entire packet has been received and
        -: 1795:	 * decrypt into incoming_packet:
        -: 1796:	 * 'aadlen' bytes are unencrypted, but authenticated.
        -: 1797:	 * 'need' bytes are encrypted, followed by either
        -: 1798:	 * 'authlen' bytes of authentication tag or
        -: 1799:	 * 'maclen' bytes of message authentication code.
        -: 1800:	 */
      126: 1801:	if (sshbuf_len(state->input) < aadlen + need + authlen + maclen)
    #####: 1802:		return 0; /* packet is incomplete */
        -: 1803:#ifdef PACKET_DEBUG
        -: 1804:	fprintf(stderr, "read_poll enc/full: ");
        -: 1805:	sshbuf_dump(state->input, stderr);
        -: 1806:#endif
        -: 1807:	/* EtM: check mac over encrypted input */
      126: 1808:	if (mac && mac->enabled && mac->etm) {
    #####: 1809:		if ((r = mac_check(mac, state->p_read.seqnr,
    #####: 1810:		    sshbuf_ptr(state->input), aadlen + need,
    #####: 1811:		    sshbuf_ptr(state->input) + aadlen + need + authlen,
        -: 1812:		    maclen)) != 0) {
    #####: 1813:			if (r == SSH_ERR_MAC_INVALID)
    #####: 1814:				logit("Corrupted MAC on input.");
    #####: 1815:			goto out;
        -: 1816:		}
        -: 1817:	}
      126: 1818:	if ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,
        -: 1819:	    &cp)) != 0)
    #####: 1820:		goto out;
      126: 1821:	if ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,
      126: 1822:	    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)
    #####: 1823:		goto out;
      126: 1824:	if ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)
    #####: 1825:		goto out;
      126: 1826:	if (mac && mac->enabled) {
        -: 1827:		/* Not EtM: check MAC over cleartext */
    #####: 1828:		if (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,
    #####: 1829:		    sshbuf_ptr(state->incoming_packet),
    #####: 1830:		    sshbuf_len(state->incoming_packet),
    #####: 1831:		    sshbuf_ptr(state->input), maclen)) != 0) {
    #####: 1832:			if (r != SSH_ERR_MAC_INVALID)
    #####: 1833:				goto out;
    #####: 1834:			logit("Corrupted MAC on input.");
    #####: 1835:			if (need > PACKET_MAX_SIZE)
    #####: 1836:				return SSH_ERR_INTERNAL_ERROR;
    #####: 1837:			return ssh_packet_start_discard(ssh, enc, mac,
    #####: 1838:			    sshbuf_len(state->incoming_packet),
        -: 1839:			    PACKET_MAX_SIZE - need);
        -: 1840:		}
        -: 1841:		/* Remove MAC from input buffer */
        -: 1842:		DBG(debug("MAC #%d ok", state->p_read.seqnr));
    #####: 1843:		if ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)
    #####: 1844:			goto out;
        -: 1845:	}
      126: 1846:	if (seqnr_p != NULL)
      126: 1847:		*seqnr_p = state->p_read.seqnr;
      126: 1848:	if (++state->p_read.seqnr == 0)
    #####: 1849:		logit("incoming seqnr wraps around");
      126: 1850:	if (++state->p_read.packets == 0)
    #####: 1851:		if (!(ssh->compat & SSH_BUG_NOREKEY))
    #####: 1852:			return SSH_ERR_NEED_REKEY;
      126: 1853:	state->p_read.blocks += (state->packlen + 4) / block_size;
      126: 1854:	state->p_read.bytes += state->packlen + 4;
        -: 1855:
        -: 1856:	/* get padlen */
      126: 1857:	padlen = sshbuf_ptr(state->incoming_packet)[4];
        -: 1858:	DBG(debug("input: padlen %d", padlen));
      126: 1859:	if (padlen < 4)	{
    #####: 1860:		if ((r = sshpkt_disconnect(ssh,
    #####: 1861:		    "Corrupted padlen %d on input.", padlen)) != 0 ||
        -: 1862:		    (r = ssh_packet_write_wait(ssh)) != 0)
    #####: 1863:			return r;
    #####: 1864:		return SSH_ERR_CONN_CORRUPT;
        -: 1865:	}
        -: 1866:
        -: 1867:	/* skip packet size + padlen, discard padding */
      252: 1868:	if ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||
      126: 1869:	    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))
        -: 1870:		goto out;
        -: 1871:
        -: 1872:	DBG(debug("input: len before de-compress %zd",
        -: 1873:	    sshbuf_len(state->incoming_packet)));
      126: 1874:	if (comp && comp->enabled) {
    #####: 1875:		sshbuf_reset(state->compression_buffer);
    #####: 1876:		if ((r = uncompress_buffer(ssh, state->incoming_packet,
        -: 1877:		    state->compression_buffer)) != 0)
    #####: 1878:			goto out;
    #####: 1879:		sshbuf_reset(state->incoming_packet);
    #####: 1880:		if ((r = sshbuf_putb(state->incoming_packet,
    #####: 1881:		    state->compression_buffer)) != 0)
    #####: 1882:			goto out;
        -: 1883:		DBG(debug("input: len after de-compress %zd",
        -: 1884:		    sshbuf_len(state->incoming_packet)));
        -: 1885:	}
        -: 1886:	/*
        -: 1887:	 * get packet type, implies consume.
        -: 1888:	 * return length of payload (without type field)
        -: 1889:	 */
      126: 1890:	if ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)
    #####: 1891:		goto out;
      126: 1892:	if (ssh_packet_log_type(*typep))
       28: 1893:		debug3("receive packet: type %u", *typep);
      126: 1894:	if (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {
    #####: 1895:		if ((r = sshpkt_disconnect(ssh,
    #####: 1896:		    "Invalid ssh2 packet type: %d", *typep)) != 0 ||
        -: 1897:		    (r = ssh_packet_write_wait(ssh)) != 0)
    #####: 1898:			return r;
    #####: 1899:		return SSH_ERR_PROTOCOL_ERROR;
        -: 1900:	}
      126: 1901:	if (state->hook_in != NULL &&
    #####: 1902:	    (r = state->hook_in(ssh, state->incoming_packet, typep,
        -: 1903:	    state->hook_in_ctx)) != 0)
    #####: 1904:		return r;
      126: 1905:	if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)
        2: 1906:		r = ssh_packet_enable_delayed_compress(ssh);
        -: 1907:	else
      124: 1908:		r = 0;
        -: 1909:#ifdef PACKET_DEBUG
        -: 1910:	fprintf(stderr, "read/plain[%d]:\r\n", *typep);
        -: 1911:	sshbuf_dump(state->incoming_packet, stderr);
        -: 1912:#endif
        -: 1913:	/* reset for next packet */
      126: 1914:	state->packlen = 0;
        -: 1915:
        -: 1916:	/* do we need to rekey? */
      126: 1917:	if (ssh_packet_need_rekeying(ssh, 0)) {
    #####: 1918:		debug3("%s: rekex triggered", __func__);
    #####: 1919:		if ((r = kex_start_rekex(ssh)) != 0)
    #####: 1920:			return r;
        -: 1921:	}
        -: 1922: out:
      126: 1923:	return r;
        -: 1924:}
        -: 1925:
        -: 1926:int
      452: 1927:ssh_packet_read_poll_seqnr(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
        -: 1928:{
      452: 1929:	struct session_state *state = ssh->state;
        -: 1930:	u_int reason, seqnr;
        -: 1931:	int r;
        -: 1932:	u_char *msg;
        -: 1933:
        -: 1934:	for (;;) {
      452: 1935:		msg = NULL;
      452: 1936:		if (compat20) {
      452: 1937:			r = ssh_packet_read_poll2(ssh, typep, seqnr_p);
      452: 1938:			if (r != 0)
    #####: 1939:				return r;
      452: 1940:			if (*typep) {
      126: 1941:				state->keep_alive_timeouts = 0;
        -: 1942:				DBG(debug("received packet type %d", *typep));
        -: 1943:			}
      452: 1944:			switch (*typep) {
        -: 1945:			case SSH2_MSG_IGNORE:
    #####: 1946:				debug3("Received SSH2_MSG_IGNORE");
    #####: 1947:				break;
        -: 1948:			case SSH2_MSG_DEBUG:
    #####: 1949:				if ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||
    #####: 1950:				    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0 ||
        -: 1951:				    (r = sshpkt_get_string(ssh, NULL, NULL)) != 0) {
    #####: 1952:					free(msg);
    #####: 1953:					return r;
        -: 1954:				}
    #####: 1955:				debug("Remote: %.900s", msg);
    #####: 1956:				free(msg);
    #####: 1957:				break;
        -: 1958:			case SSH2_MSG_DISCONNECT:
    #####: 1959:				if ((r = sshpkt_get_u32(ssh, &reason)) != 0 ||
        -: 1960:				    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0)
    #####: 1961:					return r;
        -: 1962:				/* Ignore normal client exit notifications */
    #####: 1963:				do_log2(ssh->state->server_side &&
    #####: 1964:				    reason == SSH2_DISCONNECT_BY_APPLICATION ?
        -: 1965:				    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_ERROR,
        -: 1966:				    "Received disconnect from %s port %d:"
        -: 1967:				    "%u: %.400s", ssh_remote_ipaddr(ssh),
        -: 1968:				    ssh_remote_port(ssh), reason, msg);
    #####: 1969:				free(msg);
    #####: 1970:				return SSH_ERR_DISCONNECTED;
        -: 1971:			case SSH2_MSG_UNIMPLEMENTED:
    #####: 1972:				if ((r = sshpkt_get_u32(ssh, &seqnr)) != 0)
    #####: 1973:					return r;
    #####: 1974:				debug("Received SSH2_MSG_UNIMPLEMENTED for %u",
        -: 1975:				    seqnr);
    #####: 1976:				break;
        -: 1977:			default:
      452: 1978:				return 0;
        -: 1979:			}
        -: 1980:		} else {
    #####: 1981:			r = ssh_packet_read_poll1(ssh, typep);
    #####: 1982:			switch (*typep) {
        -: 1983:			case SSH_MSG_NONE:
    #####: 1984:				return SSH_MSG_NONE;
        -: 1985:			case SSH_MSG_IGNORE:
    #####: 1986:				break;
        -: 1987:			case SSH_MSG_DEBUG:
    #####: 1988:				if ((r = sshpkt_get_string(ssh, &msg, NULL)) != 0)
    #####: 1989:					return r;
    #####: 1990:				debug("Remote: %.900s", msg);
    #####: 1991:				free(msg);
    #####: 1992:				break;
        -: 1993:			case SSH_MSG_DISCONNECT:
    #####: 1994:				if ((r = sshpkt_get_string(ssh, &msg, NULL)) != 0)
    #####: 1995:					return r;
    #####: 1996:				error("Received disconnect from %s port %d: "
        -: 1997:				    "%.400s", ssh_remote_ipaddr(ssh),
        -: 1998:				    ssh_remote_port(ssh), msg);
    #####: 1999:				free(msg);
    #####: 2000:				return SSH_ERR_DISCONNECTED;
        -: 2001:			default:
        -: 2002:				DBG(debug("received packet type %d", *typep));
    #####: 2003:				return 0;
        -: 2004:			}
        -: 2005:		}
    #####: 2006:	}
        -: 2007:}
        -: 2008:
        -: 2009:/*
        -: 2010: * Buffers the given amount of input characters.  This is intended to be used
        -: 2011: * together with packet_read_poll.
        -: 2012: */
        -: 2013:
        -: 2014:int
      103: 2015:ssh_packet_process_incoming(struct ssh *ssh, const char *buf, u_int len)
        -: 2016:{
      103: 2017:	struct session_state *state = ssh->state;
        -: 2018:	int r;
        -: 2019:
      103: 2020:	if (state->packet_discard) {
    #####: 2021:		state->keep_alive_timeouts = 0; /* ?? */
    #####: 2022:		if (len >= state->packet_discard) {
    #####: 2023:			if ((r = ssh_packet_stop_discard(ssh)) != 0)
    #####: 2024:				return r;
        -: 2025:		}
    #####: 2026:		state->packet_discard -= len;
    #####: 2027:		return 0;
        -: 2028:	}
      103: 2029:	if ((r = sshbuf_put(ssh->state->input, buf, len)) != 0)
    #####: 2030:		return r;
        -: 2031:
      103: 2032:	return 0;
        -: 2033:}
        -: 2034:
        -: 2035:int
      118: 2036:ssh_packet_remaining(struct ssh *ssh)
        -: 2037:{
      118: 2038:	return sshbuf_len(ssh->state->incoming_packet);
        -: 2039:}
        -: 2040:
        -: 2041:/*
        -: 2042: * Sends a diagnostic message from the server to the client.  This message
        -: 2043: * can be sent at any time (but not while constructing another message). The
        -: 2044: * message is printed immediately, but only if the client is being executed
        -: 2045: * in verbose mode.  These messages are primarily intended to ease debugging
        -: 2046: * authentication problems.   The length of the formatted message must not
        -: 2047: * exceed 1024 bytes.  This will automatically call ssh_packet_write_wait.
        -: 2048: */
        -: 2049:void
    #####: 2050:ssh_packet_send_debug(struct ssh *ssh, const char *fmt,...)
        -: 2051:{
        -: 2052:	char buf[1024];
        -: 2053:	va_list args;
        -: 2054:	int r;
        -: 2055:
    #####: 2056:	if (compat20 && (ssh->compat & SSH_BUG_DEBUG))
    #####: 2057:		return;
        -: 2058:
    #####: 2059:	va_start(args, fmt);
    #####: 2060:	vsnprintf(buf, sizeof(buf), fmt, args);
    #####: 2061:	va_end(args);
        -: 2062:
    #####: 2063:	if (compat20) {
    #####: 2064:		if ((r = sshpkt_start(ssh, SSH2_MSG_DEBUG)) != 0 ||
    #####: 2065:		    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* always display */
    #####: 2066:		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
    #####: 2067:		    (r = sshpkt_put_cstring(ssh, "")) != 0 ||
        -: 2068:		    (r = sshpkt_send(ssh)) != 0)
    #####: 2069:			fatal("%s: %s", __func__, ssh_err(r));
        -: 2070:	} else {
    #####: 2071:		if ((r = sshpkt_start(ssh, SSH_MSG_DEBUG)) != 0 ||
    #####: 2072:		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
        -: 2073:		    (r = sshpkt_send(ssh)) != 0)
    #####: 2074:			fatal("%s: %s", __func__, ssh_err(r));
        -: 2075:	}
    #####: 2076:	if ((r = ssh_packet_write_wait(ssh)) != 0)
    #####: 2077:		fatal("%s: %s", __func__, ssh_err(r));
        -: 2078:}
        -: 2079:
        -: 2080:/*
        -: 2081: * Pretty-print connection-terminating errors and exit.
        -: 2082: */
        -: 2083:void
    #####: 2084:sshpkt_fatal(struct ssh *ssh, const char *tag, int r)
        -: 2085:{
    #####: 2086:	switch (r) {
        -: 2087:	case SSH_ERR_CONN_CLOSED:
    #####: 2088:		logdie("Connection closed by %.200s port %d",
        -: 2089:		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
        -: 2090:	case SSH_ERR_CONN_TIMEOUT:
    #####: 2091:		logdie("Connection %s %.200s port %d timed out",
    #####: 2092:		    ssh->state->server_side ? "from" : "to",
        -: 2093:		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
        -: 2094:	case SSH_ERR_DISCONNECTED:
    #####: 2095:		logdie("Disconnected from %.200s port %d",
        -: 2096:		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
        -: 2097:	case SSH_ERR_SYSTEM_ERROR:
    #####: 2098:		if (errno == ECONNRESET)
    #####: 2099:			logdie("Connection reset by %.200s port %d",
        -: 2100:			    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
        -: 2101:		/* FALLTHROUGH */
        -: 2102:	case SSH_ERR_NO_CIPHER_ALG_MATCH:
        -: 2103:	case SSH_ERR_NO_MAC_ALG_MATCH:
        -: 2104:	case SSH_ERR_NO_COMPRESS_ALG_MATCH:
        -: 2105:	case SSH_ERR_NO_KEX_ALG_MATCH:
        -: 2106:	case SSH_ERR_NO_HOSTKEY_ALG_MATCH:
    #####: 2107:		if (ssh && ssh->kex && ssh->kex->failed_choice) {
    #####: 2108:			logdie("Unable to negotiate with %.200s port %d: %s. "
        -: 2109:			    "Their offer: %s", ssh_remote_ipaddr(ssh),
        -: 2110:			    ssh_remote_port(ssh), ssh_err(r),
    #####: 2111:			    ssh->kex->failed_choice);
        -: 2112:		}
        -: 2113:		/* FALLTHROUGH */
        -: 2114:	default:
    #####: 2115:		logdie("%s%sConnection %s %.200s port %d: %s",
        -: 2116:		    tag != NULL ? tag : "", tag != NULL ? ": " : "",
    #####: 2117:		    ssh->state->server_side ? "from" : "to",
        -: 2118:		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), ssh_err(r));
        -: 2119:	}
        -: 2120:}
        -: 2121:
        -: 2122:/*
        -: 2123: * Logs the error plus constructs and sends a disconnect packet, closes the
        -: 2124: * connection, and exits.  This function never returns. The error message
        -: 2125: * should not contain a newline.  The length of the formatted message must
        -: 2126: * not exceed 1024 bytes.
        -: 2127: */
        -: 2128:void
    #####: 2129:ssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)
        -: 2130:{
        -: 2131:	char buf[1024];
        -: 2132:	va_list args;
        -: 2133:	static int disconnecting = 0;
        -: 2134:	int r;
        -: 2135:
    #####: 2136:	if (disconnecting)	/* Guard against recursive invocations. */
    #####: 2137:		fatal("packet_disconnect called recursively.");
    #####: 2138:	disconnecting = 1;
        -: 2139:
        -: 2140:	/*
        -: 2141:	 * Format the message.  Note that the caller must make sure the
        -: 2142:	 * message is of limited size.
        -: 2143:	 */
    #####: 2144:	va_start(args, fmt);
    #####: 2145:	vsnprintf(buf, sizeof(buf), fmt, args);
    #####: 2146:	va_end(args);
        -: 2147:
        -: 2148:	/* Display the error locally */
    #####: 2149:	logit("Disconnecting: %.100s", buf);
        -: 2150:
        -: 2151:	/*
        -: 2152:	 * Send the disconnect message to the other side, and wait
        -: 2153:	 * for it to get sent.
        -: 2154:	 */
    #####: 2155:	if ((r = sshpkt_disconnect(ssh, "%s", buf)) != 0)
    #####: 2156:		sshpkt_fatal(ssh, __func__, r);
        -: 2157:
    #####: 2158:	if ((r = ssh_packet_write_wait(ssh)) != 0)
    #####: 2159:		sshpkt_fatal(ssh, __func__, r);
        -: 2160:
        -: 2161:	/* Close the connection. */
    #####: 2162:	ssh_packet_close(ssh);
    #####: 2163:	cleanup_exit(255);
        -: 2164:}
        -: 2165:
        -: 2166:/*
        -: 2167: * Checks if there is any buffered output, and tries to write some of
        -: 2168: * the output.
        -: 2169: */
        -: 2170:int
       88: 2171:ssh_packet_write_poll(struct ssh *ssh)
        -: 2172:{
       88: 2173:	struct session_state *state = ssh->state;
       88: 2174:	int len = sshbuf_len(state->output);
        -: 2175:	int r;
        -: 2176:
       88: 2177:	if (len > 0) {
      176: 2178:		len = write(state->connection_out,
       88: 2179:		    sshbuf_ptr(state->output), len);
       88: 2180:		if (len == -1) {
    #####: 2181:			if (errno == EINTR || errno == EAGAIN ||
    #####: 2182:			    errno == EWOULDBLOCK)
    #####: 2183:				return 0;
    #####: 2184:			return SSH_ERR_SYSTEM_ERROR;
        -: 2185:		}
       88: 2186:		if (len == 0)
    #####: 2187:			return SSH_ERR_CONN_CLOSED;
       88: 2188:		if ((r = sshbuf_consume(state->output, len)) != 0)
    #####: 2189:			return r;
        -: 2190:	}
       88: 2191:	return 0;
        -: 2192:}
        -: 2193:
        -: 2194:/*
        -: 2195: * Calls packet_write_poll repeatedly until all pending output data has been
        -: 2196: * written.
        -: 2197: */
        -: 2198:int
       16: 2199:ssh_packet_write_wait(struct ssh *ssh)
        -: 2200:{
        -: 2201:	fd_set *setp;
       16: 2202:	int ret, r, ms_remain = 0;
       16: 2203:	struct timeval start, timeout, *timeoutp = NULL;
       16: 2204:	struct session_state *state = ssh->state;
        -: 2205:
       16: 2206:	setp = calloc(howmany(state->connection_out + 1,
        -: 2207:	    NFDBITS), sizeof(fd_mask));
       16: 2208:	if (setp == NULL)
    #####: 2209:		return SSH_ERR_ALLOC_FAIL;
       16: 2210:	if ((r = ssh_packet_write_poll(ssh)) != 0) {
    #####: 2211:		free(setp);
    #####: 2212:		return r;
        -: 2213:	}
       32: 2214:	while (ssh_packet_have_data_to_write(ssh)) {
    #####: 2215:		memset(setp, 0, howmany(state->connection_out + 1,
        -: 2216:		    NFDBITS) * sizeof(fd_mask));
    #####: 2217:		FD_SET(state->connection_out, setp);
        -: 2218:
    #####: 2219:		if (state->packet_timeout_ms > 0) {
    #####: 2220:			ms_remain = state->packet_timeout_ms;
    #####: 2221:			timeoutp = &timeout;
        -: 2222:		}
        -: 2223:		for (;;) {
    #####: 2224:			if (state->packet_timeout_ms != -1) {
    #####: 2225:				ms_to_timeval(&timeout, ms_remain);
    #####: 2226:				gettimeofday(&start, NULL);
        -: 2227:			}
    #####: 2228:			if ((ret = select(state->connection_out + 1,
        -: 2229:			    NULL, setp, NULL, timeoutp)) >= 0)
    #####: 2230:				break;
    #####: 2231:			if (errno != EAGAIN && errno != EINTR &&
    #####: 2232:			    errno != EWOULDBLOCK)
    #####: 2233:				break;
    #####: 2234:			if (state->packet_timeout_ms == -1)
    #####: 2235:				continue;
    #####: 2236:			ms_subtract_diff(&start, &ms_remain);
    #####: 2237:			if (ms_remain <= 0) {
    #####: 2238:				ret = 0;
    #####: 2239:				break;
        -: 2240:			}
    #####: 2241:		}
    #####: 2242:		if (ret == 0) {
    #####: 2243:			free(setp);
    #####: 2244:			return SSH_ERR_CONN_TIMEOUT;
        -: 2245:		}
    #####: 2246:		if ((r = ssh_packet_write_poll(ssh)) != 0) {
    #####: 2247:			free(setp);
    #####: 2248:			return r;
        -: 2249:		}
        -: 2250:	}
       16: 2251:	free(setp);
       16: 2252:	return 0;
        -: 2253:}
        -: 2254:
        -: 2255:/* Returns true if there is buffered data to write to the connection. */
        -: 2256:
        -: 2257:int
      330: 2258:ssh_packet_have_data_to_write(struct ssh *ssh)
        -: 2259:{
      330: 2260:	return sshbuf_len(ssh->state->output) != 0;
        -: 2261:}
        -: 2262:
        -: 2263:/* Returns true if there is not too much data to write to the connection. */
        -: 2264:
        -: 2265:int
      312: 2266:ssh_packet_not_very_much_data_to_write(struct ssh *ssh)
        -: 2267:{
      312: 2268:	if (ssh->state->interactive_mode)
      308: 2269:		return sshbuf_len(ssh->state->output) < 16384;
        -: 2270:	else
        4: 2271:		return sshbuf_len(ssh->state->output) < 128 * 1024;
        -: 2272:}
        -: 2273:
        -: 2274:void
        2: 2275:ssh_packet_set_tos(struct ssh *ssh, int tos)
        -: 2276:{
        -: 2277:#ifndef IP_TOS_IS_BROKEN
        2: 2278:	if (!ssh_packet_connection_is_on_socket(ssh))
        2: 2279:		return;
        2: 2280:	switch (ssh_packet_connection_af(ssh)) {
        -: 2281:# ifdef IP_TOS
        -: 2282:	case AF_INET:
        2: 2283:		debug3("%s: set IP_TOS 0x%02x", __func__, tos);
        2: 2284:		if (setsockopt(ssh->state->connection_in,
        -: 2285:		    IPPROTO_IP, IP_TOS, &tos, sizeof(tos)) < 0)
    #####: 2286:			error("setsockopt IP_TOS %d: %.100s:",
    #####: 2287:			    tos, strerror(errno));
        2: 2288:		break;
        -: 2289:# endif /* IP_TOS */
        -: 2290:# ifdef IPV6_TCLASS
        -: 2291:	case AF_INET6:
    #####: 2292:		debug3("%s: set IPV6_TCLASS 0x%02x", __func__, tos);
    #####: 2293:		if (setsockopt(ssh->state->connection_in,
        -: 2294:		    IPPROTO_IPV6, IPV6_TCLASS, &tos, sizeof(tos)) < 0)
    #####: 2295:			error("setsockopt IPV6_TCLASS %d: %.100s:",
    #####: 2296:			    tos, strerror(errno));
    #####: 2297:		break;
        -: 2298:# endif /* IPV6_TCLASS */
        -: 2299:	}
        -: 2300:#endif /* IP_TOS_IS_BROKEN */
        -: 2301:}
        -: 2302:
        -: 2303:/* Informs that the current session is interactive.  Sets IP flags for that. */
        -: 2304:
        -: 2305:void
        4: 2306:ssh_packet_set_interactive(struct ssh *ssh, int interactive, int qos_interactive, int qos_bulk)
        -: 2307:{
        4: 2308:	struct session_state *state = ssh->state;
        -: 2309:
        4: 2310:	if (state->set_interactive_called)
        2: 2311:		return;
        2: 2312:	state->set_interactive_called = 1;
        -: 2313:
        -: 2314:	/* Record that we are in interactive mode. */
        2: 2315:	state->interactive_mode = interactive;
        -: 2316:
        -: 2317:	/* Only set socket options if using a socket.  */
        2: 2318:	if (!ssh_packet_connection_is_on_socket(ssh))
    #####: 2319:		return;
        2: 2320:	set_nodelay(state->connection_in);
        2: 2321:	ssh_packet_set_tos(ssh, interactive ? qos_interactive :
        -: 2322:	    qos_bulk);
        -: 2323:}
        -: 2324:
        -: 2325:/* Returns true if the current connection is interactive. */
        -: 2326:
        -: 2327:int
    #####: 2328:ssh_packet_is_interactive(struct ssh *ssh)
        -: 2329:{
    #####: 2330:	return ssh->state->interactive_mode;
        -: 2331:}
        -: 2332:
        -: 2333:int
    #####: 2334:ssh_packet_set_maxsize(struct ssh *ssh, u_int s)
        -: 2335:{
    #####: 2336:	struct session_state *state = ssh->state;
        -: 2337:
    #####: 2338:	if (state->set_maxsize_called) {
    #####: 2339:		logit("packet_set_maxsize: called twice: old %d new %d",
        -: 2340:		    state->max_packet_size, s);
    #####: 2341:		return -1;
        -: 2342:	}
    #####: 2343:	if (s < 4 * 1024 || s > 1024 * 1024) {
    #####: 2344:		logit("packet_set_maxsize: bad size %d", s);
    #####: 2345:		return -1;
        -: 2346:	}
    #####: 2347:	state->set_maxsize_called = 1;
    #####: 2348:	debug("packet_set_maxsize: setting to %d", s);
    #####: 2349:	state->max_packet_size = s;
    #####: 2350:	return s;
        -: 2351:}
        -: 2352:
        -: 2353:int
    #####: 2354:ssh_packet_inc_alive_timeouts(struct ssh *ssh)
        -: 2355:{
    #####: 2356:	return ++ssh->state->keep_alive_timeouts;
        -: 2357:}
        -: 2358:
        -: 2359:void
        4: 2360:ssh_packet_set_alive_timeouts(struct ssh *ssh, int ka)
        -: 2361:{
        4: 2362:	ssh->state->keep_alive_timeouts = ka;
        4: 2363:}
        -: 2364:
        -: 2365:u_int
    #####: 2366:ssh_packet_get_maxsize(struct ssh *ssh)
        -: 2367:{
    #####: 2368:	return ssh->state->max_packet_size;
        -: 2369:}
        -: 2370:
        -: 2371:/*
        -: 2372: * 9.2.  Ignored Data Message
        -: 2373: *
        -: 2374: *   byte      SSH_MSG_IGNORE
        -: 2375: *   string    data
        -: 2376: *
        -: 2377: * All implementations MUST understand (and ignore) this message at any
        -: 2378: * time (after receiving the protocol version). No implementation is
        -: 2379: * required to send them. This message can be used as an additional
        -: 2380: * protection measure against advanced traffic analysis techniques.
        -: 2381: */
        -: 2382:void
    #####: 2383:ssh_packet_send_ignore(struct ssh *ssh, int nbytes)
        -: 2384:{
    #####: 2385:	u_int32_t rnd = 0;
        -: 2386:	int r, i;
        -: 2387:
    #####: 2388:	if ((r = sshpkt_start(ssh, compat20 ?
    #####: 2389:	    SSH2_MSG_IGNORE : SSH_MSG_IGNORE)) != 0 ||
    #####: 2390:	    (r = sshpkt_put_u32(ssh, nbytes)) != 0)
    #####: 2391:		fatal("%s: %s", __func__, ssh_err(r));
    #####: 2392:	for (i = 0; i < nbytes; i++) {
    #####: 2393:		if (i % 4 == 0)
    #####: 2394:			rnd = arc4random();
    #####: 2395:		if ((r = sshpkt_put_u8(ssh, (u_char)rnd & 0xff)) != 0)
    #####: 2396:			fatal("%s: %s", __func__, ssh_err(r));
    #####: 2397:		rnd >>= 8;
        -: 2398:	}
    #####: 2399:}
        -: 2400:
        -: 2401:void
    #####: 2402:ssh_packet_set_rekey_limits(struct ssh *ssh, u_int64_t bytes, time_t seconds)
        -: 2403:{
    #####: 2404:	debug3("rekey after %llu bytes, %d seconds", (unsigned long long)bytes,
        -: 2405:	    (int)seconds);
    #####: 2406:	ssh->state->rekey_limit = bytes;
    #####: 2407:	ssh->state->rekey_interval = seconds;
    #####: 2408:}
        -: 2409:
        -: 2410:time_t
    #####: 2411:ssh_packet_get_rekey_timeout(struct ssh *ssh)
        -: 2412:{
        -: 2413:	time_t seconds;
        -: 2414:
    #####: 2415:	seconds = ssh->state->rekey_time + ssh->state->rekey_interval -
    #####: 2416:	    monotime();
    #####: 2417:	return (seconds <= 0 ? 1 : seconds);
        -: 2418:}
        -: 2419:
        -: 2420:void
    #####: 2421:ssh_packet_set_server(struct ssh *ssh)
        -: 2422:{
    #####: 2423:	ssh->state->server_side = 1;
    #####: 2424:}
        -: 2425:
        -: 2426:void
    #####: 2427:ssh_packet_set_authenticated(struct ssh *ssh)
        -: 2428:{
    #####: 2429:	ssh->state->after_authentication = 1;
    #####: 2430:}
        -: 2431:
        -: 2432:void *
    #####: 2433:ssh_packet_get_input(struct ssh *ssh)
        -: 2434:{
    #####: 2435:	return (void *)ssh->state->input;
        -: 2436:}
        -: 2437:
        -: 2438:void *
    #####: 2439:ssh_packet_get_output(struct ssh *ssh)
        -: 2440:{
    #####: 2441:	return (void *)ssh->state->output;
        -: 2442:}
        -: 2443:
        -: 2444:/* Reset after_authentication and reset compression in post-auth privsep */
        -: 2445:static int
    #####: 2446:ssh_packet_set_postauth(struct ssh *ssh)
        -: 2447:{
        -: 2448:	int r;
        -: 2449:
    #####: 2450:	debug("%s: called", __func__);
        -: 2451:	/* This was set in net child, but is not visible in user child */
    #####: 2452:	ssh->state->after_authentication = 1;
    #####: 2453:	ssh->state->rekeying = 0;
    #####: 2454:	if ((r = ssh_packet_enable_delayed_compress(ssh)) != 0)
    #####: 2455:		return r;
    #####: 2456:	return 0;
        -: 2457:}
        -: 2458:
        -: 2459:/* Packet state (de-)serialization for privsep */
        -: 2460:
        -: 2461:/* turn kex into a blob for packet state serialization */
        -: 2462:static int
    #####: 2463:kex_to_blob(struct sshbuf *m, struct kex *kex)
        -: 2464:{
        -: 2465:	int r;
        -: 2466:
    #####: 2467:	if ((r = sshbuf_put_string(m, kex->session_id,
    #####: 2468:	    kex->session_id_len)) != 0 ||
    #####: 2469:	    (r = sshbuf_put_u32(m, kex->we_need)) != 0 ||
    #####: 2470:	    (r = sshbuf_put_u32(m, kex->hostkey_type)) != 0 ||
    #####: 2471:	    (r = sshbuf_put_u32(m, kex->kex_type)) != 0 ||
    #####: 2472:	    (r = sshbuf_put_stringb(m, kex->my)) != 0 ||
    #####: 2473:	    (r = sshbuf_put_stringb(m, kex->peer)) != 0 ||
    #####: 2474:	    (r = sshbuf_put_u32(m, kex->flags)) != 0 ||
    #####: 2475:	    (r = sshbuf_put_cstring(m, kex->client_version_string)) != 0 ||
    #####: 2476:	    (r = sshbuf_put_cstring(m, kex->server_version_string)) != 0)
    #####: 2477:		return r;
    #####: 2478:	return 0;
        -: 2479:}
        -: 2480:
        -: 2481:/* turn key exchange results into a blob for packet state serialization */
        -: 2482:static int
    #####: 2483:newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)
        -: 2484:{
        -: 2485:	struct sshbuf *b;
        -: 2486:	struct sshcipher_ctx *cc;
        -: 2487:	struct sshcomp *comp;
        -: 2488:	struct sshenc *enc;
        -: 2489:	struct sshmac *mac;
        -: 2490:	struct newkeys *newkey;
        -: 2491:	int r;
        -: 2492:
    #####: 2493:	if ((newkey = ssh->state->newkeys[mode]) == NULL)
    #####: 2494:		return SSH_ERR_INTERNAL_ERROR;
    #####: 2495:	enc = &newkey->enc;
    #####: 2496:	mac = &newkey->mac;
    #####: 2497:	comp = &newkey->comp;
    #####: 2498:	cc = (mode == MODE_OUT) ? ssh->state->send_context :
    #####: 2499:	    ssh->state->receive_context;
    #####: 2500:	if ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)
    #####: 2501:		return r;
    #####: 2502:	if ((b = sshbuf_new()) == NULL)
    #####: 2503:		return SSH_ERR_ALLOC_FAIL;
        -: 2504:	/* The cipher struct is constant and shared, you export pointer */
    #####: 2505:	if ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||
    #####: 2506:	    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||
    #####: 2507:	    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||
    #####: 2508:	    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||
    #####: 2509:	    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||
    #####: 2510:	    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)
        -: 2511:		goto out;
    #####: 2512:	if (cipher_authlen(enc->cipher) == 0) {
    #####: 2513:		if ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||
    #####: 2514:		    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||
    #####: 2515:		    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)
        -: 2516:			goto out;
        -: 2517:	}
    #####: 2518:	if ((r = sshbuf_put_u32(b, comp->type)) != 0 ||
    #####: 2519:	    (r = sshbuf_put_cstring(b, comp->name)) != 0)
        -: 2520:		goto out;
    #####: 2521:	r = sshbuf_put_stringb(m, b);
        -: 2522: out:
    #####: 2523:	sshbuf_free(b);
    #####: 2524:	return r;
        -: 2525:}
        -: 2526:
        -: 2527:/* serialize packet state into a blob */
        -: 2528:int
    #####: 2529:ssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)
        -: 2530:{
    #####: 2531:	struct session_state *state = ssh->state;
        -: 2532:	u_char *p;
        -: 2533:	size_t slen, rlen;
        -: 2534:	int r, ssh1cipher;
        -: 2535:
    #####: 2536:	if (!compat20) {
    #####: 2537:		ssh1cipher = cipher_ctx_get_number(state->receive_context);
    #####: 2538:		slen = cipher_get_keyiv_len(state->send_context);
    #####: 2539:		rlen = cipher_get_keyiv_len(state->receive_context);
    #####: 2540:		if ((r = sshbuf_put_u32(m, state->remote_protocol_flags)) != 0 ||
    #####: 2541:		    (r = sshbuf_put_u32(m, ssh1cipher)) != 0 ||
    #####: 2542:		    (r = sshbuf_put_string(m, state->ssh1_key, state->ssh1_keylen)) != 0 ||
    #####: 2543:		    (r = sshbuf_put_u32(m, slen)) != 0 ||
    #####: 2544:		    (r = sshbuf_reserve(m, slen, &p)) != 0 ||
    #####: 2545:		    (r = cipher_get_keyiv(state->send_context, p, slen)) != 0 ||
    #####: 2546:		    (r = sshbuf_put_u32(m, rlen)) != 0 ||
    #####: 2547:		    (r = sshbuf_reserve(m, rlen, &p)) != 0 ||
    #####: 2548:		    (r = cipher_get_keyiv(state->receive_context, p, rlen)) != 0)
    #####: 2549:			return r;
        -: 2550:	} else {
    #####: 2551:		if ((r = kex_to_blob(m, ssh->kex)) != 0 ||
    #####: 2552:		    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||
    #####: 2553:		    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||
    #####: 2554:		    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||
    #####: 2555:		    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||
    #####: 2556:		    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||
    #####: 2557:		    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||
    #####: 2558:		    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||
    #####: 2559:		    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||
    #####: 2560:		    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||
    #####: 2561:		    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||
    #####: 2562:		    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||
    #####: 2563:		    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0)
    #####: 2564:			return r;
        -: 2565:	}
        -: 2566:
    #####: 2567:	slen = cipher_get_keycontext(state->send_context, NULL);
    #####: 2568:	rlen = cipher_get_keycontext(state->receive_context, NULL);
    #####: 2569:	if ((r = sshbuf_put_u32(m, slen)) != 0 ||
        -: 2570:	    (r = sshbuf_reserve(m, slen, &p)) != 0)
    #####: 2571:		return r;
    #####: 2572:	if (cipher_get_keycontext(state->send_context, p) != (int)slen)
    #####: 2573:		return SSH_ERR_INTERNAL_ERROR;
    #####: 2574:	if ((r = sshbuf_put_u32(m, rlen)) != 0 ||
        -: 2575:	    (r = sshbuf_reserve(m, rlen, &p)) != 0)
    #####: 2576:		return r;
    #####: 2577:	if (cipher_get_keycontext(state->receive_context, p) != (int)rlen)
    #####: 2578:		return SSH_ERR_INTERNAL_ERROR;
    #####: 2579:	if ((r = sshbuf_put_stringb(m, state->input)) != 0 ||
    #####: 2580:	    (r = sshbuf_put_stringb(m, state->output)) != 0)
    #####: 2581:		return r;
        -: 2582:
    #####: 2583:	return 0;
        -: 2584:}
        -: 2585:
        -: 2586:/* restore key exchange results from blob for packet state de-serialization */
        -: 2587:static int
    #####: 2588:newkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)
        -: 2589:{
    #####: 2590:	struct sshbuf *b = NULL;
        -: 2591:	struct sshcomp *comp;
        -: 2592:	struct sshenc *enc;
        -: 2593:	struct sshmac *mac;
    #####: 2594:	struct newkeys *newkey = NULL;
        -: 2595:	size_t keylen, ivlen, maclen;
        -: 2596:	int r;
        -: 2597:
    #####: 2598:	if ((newkey = calloc(1, sizeof(*newkey))) == NULL) {
    #####: 2599:		r = SSH_ERR_ALLOC_FAIL;
    #####: 2600:		goto out;
        -: 2601:	}
    #####: 2602:	if ((r = sshbuf_froms(m, &b)) != 0)
    #####: 2603:		goto out;
        -: 2604:#ifdef DEBUG_PK
        -: 2605:	sshbuf_dump(b, stderr);
        -: 2606:#endif
    #####: 2607:	enc = &newkey->enc;
    #####: 2608:	mac = &newkey->mac;
    #####: 2609:	comp = &newkey->comp;
        -: 2610:
    #####: 2611:	if ((r = sshbuf_get_cstring(b, &enc->name, NULL)) != 0 ||
    #####: 2612:	    (r = sshbuf_get(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||
    #####: 2613:	    (r = sshbuf_get_u32(b, (u_int *)&enc->enabled)) != 0 ||
    #####: 2614:	    (r = sshbuf_get_u32(b, &enc->block_size)) != 0 ||
    #####: 2615:	    (r = sshbuf_get_string(b, &enc->key, &keylen)) != 0 ||
    #####: 2616:	    (r = sshbuf_get_string(b, &enc->iv, &ivlen)) != 0)
        -: 2617:		goto out;
    #####: 2618:	if (cipher_authlen(enc->cipher) == 0) {
    #####: 2619:		if ((r = sshbuf_get_cstring(b, &mac->name, NULL)) != 0)
    #####: 2620:			goto out;
    #####: 2621:		if ((r = mac_setup(mac, mac->name)) != 0)
    #####: 2622:			goto out;
    #####: 2623:		if ((r = sshbuf_get_u32(b, (u_int *)&mac->enabled)) != 0 ||
    #####: 2624:		    (r = sshbuf_get_string(b, &mac->key, &maclen)) != 0)
        -: 2625:			goto out;
    #####: 2626:		if (maclen > mac->key_len) {
    #####: 2627:			r = SSH_ERR_INVALID_FORMAT;
    #####: 2628:			goto out;
        -: 2629:		}
    #####: 2630:		mac->key_len = maclen;
        -: 2631:	}
    #####: 2632:	if ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||
    #####: 2633:	    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)
        -: 2634:		goto out;
    #####: 2635:	if (enc->name == NULL ||
    #####: 2636:	    cipher_by_name(enc->name) != enc->cipher) {
    #####: 2637:		r = SSH_ERR_INVALID_FORMAT;
    #####: 2638:		goto out;
        -: 2639:	}
    #####: 2640:	if (sshbuf_len(b) != 0) {
    #####: 2641:		r = SSH_ERR_INVALID_FORMAT;
    #####: 2642:		goto out;
        -: 2643:	}
    #####: 2644:	enc->key_len = keylen;
    #####: 2645:	enc->iv_len = ivlen;
    #####: 2646:	ssh->kex->newkeys[mode] = newkey;
    #####: 2647:	newkey = NULL;
    #####: 2648:	r = 0;
        -: 2649: out:
    #####: 2650:	free(newkey);
    #####: 2651:	sshbuf_free(b);
    #####: 2652:	return r;
        -: 2653:}
        -: 2654:
        -: 2655:/* restore kex from blob for packet state de-serialization */
        -: 2656:static int
    #####: 2657:kex_from_blob(struct sshbuf *m, struct kex **kexp)
        -: 2658:{
        -: 2659:	struct kex *kex;
        -: 2660:	int r;
        -: 2661:
    #####: 2662:	if ((kex = calloc(1, sizeof(struct kex))) == NULL ||
    #####: 2663:	    (kex->my = sshbuf_new()) == NULL ||
    #####: 2664:	    (kex->peer = sshbuf_new()) == NULL) {
    #####: 2665:		r = SSH_ERR_ALLOC_FAIL;
    #####: 2666:		goto out;
        -: 2667:	}
    #####: 2668:	if ((r = sshbuf_get_string(m, &kex->session_id, &kex->session_id_len)) != 0 ||
    #####: 2669:	    (r = sshbuf_get_u32(m, &kex->we_need)) != 0 ||
    #####: 2670:	    (r = sshbuf_get_u32(m, (u_int *)&kex->hostkey_type)) != 0 ||
    #####: 2671:	    (r = sshbuf_get_u32(m, &kex->kex_type)) != 0 ||
    #####: 2672:	    (r = sshbuf_get_stringb(m, kex->my)) != 0 ||
    #####: 2673:	    (r = sshbuf_get_stringb(m, kex->peer)) != 0 ||
    #####: 2674:	    (r = sshbuf_get_u32(m, &kex->flags)) != 0 ||
    #####: 2675:	    (r = sshbuf_get_cstring(m, &kex->client_version_string, NULL)) != 0 ||
    #####: 2676:	    (r = sshbuf_get_cstring(m, &kex->server_version_string, NULL)) != 0)
        -: 2677:		goto out;
    #####: 2678:	kex->server = 1;
    #####: 2679:	kex->done = 1;
    #####: 2680:	r = 0;
        -: 2681: out:
    #####: 2682:	if (r != 0 || kexp == NULL) {
    #####: 2683:		if (kex != NULL) {
    #####: 2684:			sshbuf_free(kex->my);
    #####: 2685:			sshbuf_free(kex->peer);
    #####: 2686:			free(kex);
        -: 2687:		}
    #####: 2688:		if (kexp != NULL)
    #####: 2689:			*kexp = NULL;
        -: 2690:	} else {
    #####: 2691:		*kexp = kex;
        -: 2692:	}
    #####: 2693:	return r;
        -: 2694:}
        -: 2695:
        -: 2696:/*
        -: 2697: * Restore packet state from content of blob 'm' (de-serialization).
        -: 2698: * Note that 'm' will be partially consumed on parsing or any other errors.
        -: 2699: */
        -: 2700:int
    #####: 2701:ssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)
        -: 2702:{
    #####: 2703:	struct session_state *state = ssh->state;
        -: 2704:	const u_char *ssh1key, *ivin, *ivout, *keyin, *keyout, *input, *output;
        -: 2705:	size_t ssh1keylen, rlen, slen, ilen, olen;
        -: 2706:	int r;
    #####: 2707:	u_int ssh1cipher = 0;
        -: 2708:
    #####: 2709:	if (!compat20) {
    #####: 2710:		if ((r = sshbuf_get_u32(m, &state->remote_protocol_flags)) != 0 ||
    #####: 2711:		    (r = sshbuf_get_u32(m, &ssh1cipher)) != 0 ||
    #####: 2712:		    (r = sshbuf_get_string_direct(m, &ssh1key, &ssh1keylen)) != 0 ||
    #####: 2713:		    (r = sshbuf_get_string_direct(m, &ivout, &slen)) != 0 ||
        -: 2714:		    (r = sshbuf_get_string_direct(m, &ivin, &rlen)) != 0)
    #####: 2715:			return r;
    #####: 2716:		if (ssh1cipher > INT_MAX)
    #####: 2717:			return SSH_ERR_KEY_UNKNOWN_CIPHER;
    #####: 2718:		ssh_packet_set_encryption_key(ssh, ssh1key, ssh1keylen,
        -: 2719:		    (int)ssh1cipher);
    #####: 2720:		if (cipher_get_keyiv_len(state->send_context) != (int)slen ||
    #####: 2721:		    cipher_get_keyiv_len(state->receive_context) != (int)rlen)
    #####: 2722:			return SSH_ERR_INVALID_FORMAT;
    #####: 2723:		if ((r = cipher_set_keyiv(state->send_context, ivout)) != 0 ||
    #####: 2724:		    (r = cipher_set_keyiv(state->receive_context, ivin)) != 0)
    #####: 2725:			return r;
        -: 2726:	} else {
    #####: 2727:		if ((r = kex_from_blob(m, &ssh->kex)) != 0 ||
    #####: 2728:		    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||
    #####: 2729:		    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||
    #####: 2730:		    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||
    #####: 2731:		    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||
    #####: 2732:		    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||
    #####: 2733:		    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||
    #####: 2734:		    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||
    #####: 2735:		    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||
    #####: 2736:		    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||
    #####: 2737:		    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||
    #####: 2738:		    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||
    #####: 2739:		    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)
    #####: 2740:			return r;
        -: 2741:		/*
        -: 2742:		 * We set the time here so that in post-auth privsep slave we
        -: 2743:		 * count from the completion of the authentication.
        -: 2744:		 */
    #####: 2745:		state->rekey_time = monotime();
        -: 2746:		/* XXX ssh_set_newkeys overrides p_read.packets? XXX */
    #####: 2747:		if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||
        -: 2748:		    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)
    #####: 2749:			return r;
        -: 2750:	}
    #####: 2751:	if ((r = sshbuf_get_string_direct(m, &keyout, &slen)) != 0 ||
        -: 2752:	    (r = sshbuf_get_string_direct(m, &keyin, &rlen)) != 0)
    #####: 2753:		return r;
    #####: 2754:	if (cipher_get_keycontext(state->send_context, NULL) != (int)slen ||
    #####: 2755:	    cipher_get_keycontext(state->receive_context, NULL) != (int)rlen)
    #####: 2756:		return SSH_ERR_INVALID_FORMAT;
    #####: 2757:	cipher_set_keycontext(state->send_context, keyout);
    #####: 2758:	cipher_set_keycontext(state->receive_context, keyin);
        -: 2759:
    #####: 2760:	if ((r = ssh_packet_set_postauth(ssh)) != 0)
    #####: 2761:		return r;
        -: 2762:
    #####: 2763:	sshbuf_reset(state->input);
    #####: 2764:	sshbuf_reset(state->output);
    #####: 2765:	if ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||
    #####: 2766:	    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||
    #####: 2767:	    (r = sshbuf_put(state->input, input, ilen)) != 0 ||
    #####: 2768:	    (r = sshbuf_put(state->output, output, olen)) != 0)
    #####: 2769:		return r;
        -: 2770:
    #####: 2771:	if (sshbuf_len(m))
    #####: 2772:		return SSH_ERR_INVALID_FORMAT;
    #####: 2773:	debug3("%s: done", __func__);
    #####: 2774:	return 0;
        -: 2775:}
        -: 2776:
        -: 2777:/* NEW API */
        -: 2778:
        -: 2779:/* put data to the outgoing packet */
        -: 2780:
        -: 2781:int
        2: 2782:sshpkt_put(struct ssh *ssh, const void *v, size_t len)
        -: 2783:{
        2: 2784:	return sshbuf_put(ssh->state->outgoing_packet, v, len);
        -: 2785:}
        -: 2786:
        -: 2787:int
        2: 2788:sshpkt_putb(struct ssh *ssh, const struct sshbuf *b)
        -: 2789:{
        2: 2790:	return sshbuf_putb(ssh->state->outgoing_packet, b);
        -: 2791:}
        -: 2792:
        -: 2793:int
        8: 2794:sshpkt_put_u8(struct ssh *ssh, u_char val)
        -: 2795:{
        8: 2796:	return sshbuf_put_u8(ssh->state->outgoing_packet, val);
        -: 2797:}
        -: 2798:
        -: 2799:int
       88: 2800:sshpkt_put_u32(struct ssh *ssh, u_int32_t val)
        -: 2801:{
       88: 2802:	return sshbuf_put_u32(ssh->state->outgoing_packet, val);
        -: 2803:}
        -: 2804:
        -: 2805:int
    #####: 2806:sshpkt_put_u64(struct ssh *ssh, u_int64_t val)
        -: 2807:{
    #####: 2808:	return sshbuf_put_u64(ssh->state->outgoing_packet, val);
        -: 2809:}
        -: 2810:
        -: 2811:int
       72: 2812:sshpkt_put_string(struct ssh *ssh, const void *v, size_t len)
        -: 2813:{
       72: 2814:	return sshbuf_put_string(ssh->state->outgoing_packet, v, len);
        -: 2815:}
        -: 2816:
        -: 2817:int
       30: 2818:sshpkt_put_cstring(struct ssh *ssh, const void *v)
        -: 2819:{
       30: 2820:	return sshbuf_put_cstring(ssh->state->outgoing_packet, v);
        -: 2821:}
        -: 2822:
        -: 2823:int
    #####: 2824:sshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v)
        -: 2825:{
    #####: 2826:	return sshbuf_put_stringb(ssh->state->outgoing_packet, v);
        -: 2827:}
        -: 2828:
        -: 2829:#ifdef WITH_OPENSSL
        -: 2830:#ifdef OPENSSL_HAS_ECC
        -: 2831:int
    #####: 2832:sshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)
        -: 2833:{
    #####: 2834:	return sshbuf_put_ec(ssh->state->outgoing_packet, v, g);
        -: 2835:}
        -: 2836:#endif /* OPENSSL_HAS_ECC */
        -: 2837:
        -: 2838:#ifdef WITH_SSH1
        -: 2839:int
        -: 2840:sshpkt_put_bignum1(struct ssh *ssh, const BIGNUM *v)
        -: 2841:{
        -: 2842:	return sshbuf_put_bignum1(ssh->state->outgoing_packet, v);
        -: 2843:}
        -: 2844:#endif /* WITH_SSH1 */
        -: 2845:
        -: 2846:int
    #####: 2847:sshpkt_put_bignum2(struct ssh *ssh, const BIGNUM *v)
        -: 2848:{
    #####: 2849:	return sshbuf_put_bignum2(ssh->state->outgoing_packet, v);
        -: 2850:}
        -: 2851:#endif /* WITH_OPENSSL */
        -: 2852:
        -: 2853:/* fetch data from the incoming packet */
        -: 2854:
        -: 2855:int
    #####: 2856:sshpkt_get(struct ssh *ssh, void *valp, size_t len)
        -: 2857:{
    #####: 2858:	return sshbuf_get(ssh->state->incoming_packet, valp, len);
        -: 2859:}
        -: 2860:
        -: 2861:int
       40: 2862:sshpkt_get_u8(struct ssh *ssh, u_char *valp)
        -: 2863:{
       40: 2864:	return sshbuf_get_u8(ssh->state->incoming_packet, valp);
        -: 2865:}
        -: 2866:
        -: 2867:int
      124: 2868:sshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)
        -: 2869:{
      124: 2870:	return sshbuf_get_u32(ssh->state->incoming_packet, valp);
        -: 2871:}
        -: 2872:
        -: 2873:int
    #####: 2874:sshpkt_get_u64(struct ssh *ssh, u_int64_t *valp)
        -: 2875:{
    #####: 2876:	return sshbuf_get_u64(ssh->state->incoming_packet, valp);
        -: 2877:}
        -: 2878:
        -: 2879:int
       36: 2880:sshpkt_get_string(struct ssh *ssh, u_char **valp, size_t *lenp)
        -: 2881:{
       36: 2882:	return sshbuf_get_string(ssh->state->incoming_packet, valp, lenp);
        -: 2883:}
        -: 2884:
        -: 2885:int
       96: 2886:sshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)
        -: 2887:{
       96: 2888:	return sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);
        -: 2889:}
        -: 2890:
        -: 2891:int
        2: 2892:sshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)
        -: 2893:{
        2: 2894:	return sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);
        -: 2895:}
        -: 2896:
        -: 2897:#ifdef WITH_OPENSSL
        -: 2898:#ifdef OPENSSL_HAS_ECC
        -: 2899:int
    #####: 2900:sshpkt_get_ec(struct ssh *ssh, EC_POINT *v, const EC_GROUP *g)
        -: 2901:{
    #####: 2902:	return sshbuf_get_ec(ssh->state->incoming_packet, v, g);
        -: 2903:}
        -: 2904:#endif /* OPENSSL_HAS_ECC */
        -: 2905:
        -: 2906:#ifdef WITH_SSH1
        -: 2907:int
        -: 2908:sshpkt_get_bignum1(struct ssh *ssh, BIGNUM *v)
        -: 2909:{
        -: 2910:	return sshbuf_get_bignum1(ssh->state->incoming_packet, v);
        -: 2911:}
        -: 2912:#endif /* WITH_SSH1 */
        -: 2913:
        -: 2914:int
    #####: 2915:sshpkt_get_bignum2(struct ssh *ssh, BIGNUM *v)
        -: 2916:{
    #####: 2917:	return sshbuf_get_bignum2(ssh->state->incoming_packet, v);
        -: 2918:}
        -: 2919:#endif /* WITH_OPENSSL */
        -: 2920:
        -: 2921:int
        8: 2922:sshpkt_get_end(struct ssh *ssh)
        -: 2923:{
        8: 2924:	if (sshbuf_len(ssh->state->incoming_packet) > 0)
    #####: 2925:		return SSH_ERR_UNEXPECTED_TRAILING_DATA;
        8: 2926:	return 0;
        -: 2927:}
        -: 2928:
        -: 2929:const u_char *
        2: 2930:sshpkt_ptr(struct ssh *ssh, size_t *lenp)
        -: 2931:{
        2: 2932:	if (lenp != NULL)
        2: 2933:		*lenp = sshbuf_len(ssh->state->incoming_packet);
        2: 2934:	return sshbuf_ptr(ssh->state->incoming_packet);
        -: 2935:}
        -: 2936:
        -: 2937:/* start a new packet */
        -: 2938:
        -: 2939:int
       92: 2940:sshpkt_start(struct ssh *ssh, u_char type)
        -: 2941:{
        -: 2942:	u_char buf[9];
        -: 2943:	int len;
        -: 2944:
        -: 2945:	DBG(debug("packet_start[%d]", type));
       92: 2946:	len = compat20 ? 6 : 9;
       92: 2947:	memset(buf, 0, len - 1);
       92: 2948:	buf[len - 1] = type;
       92: 2949:	sshbuf_reset(ssh->state->outgoing_packet);
       92: 2950:	return sshbuf_put(ssh->state->outgoing_packet, buf, len);
        -: 2951:}
        -: 2952:
        -: 2953:static int
    #####: 2954:ssh_packet_send_mux(struct ssh *ssh)
        -: 2955:{
    #####: 2956:	struct session_state *state = ssh->state;
        -: 2957:	u_char type, *cp;
        -: 2958:	size_t len;
        -: 2959:	int r;
        -: 2960:
    #####: 2961:	if (ssh->kex)
    #####: 2962:		return SSH_ERR_INTERNAL_ERROR;
    #####: 2963:	len = sshbuf_len(state->outgoing_packet);
    #####: 2964:	if (len < 6)
    #####: 2965:		return SSH_ERR_INTERNAL_ERROR;
    #####: 2966:	cp = sshbuf_mutable_ptr(state->outgoing_packet);
    #####: 2967:	type = cp[5];
    #####: 2968:	if (ssh_packet_log_type(type))
    #####: 2969:		debug3("%s: type %u", __func__, type);
        -: 2970:	/* drop everything, but the connection protocol */
    #####: 2971:	if (type >= SSH2_MSG_CONNECTION_MIN &&
    #####: 2972:	    type <= SSH2_MSG_CONNECTION_MAX) {
    #####: 2973:		POKE_U32(cp, len - 4);
    #####: 2974:		if ((r = sshbuf_putb(state->output,
    #####: 2975:		    state->outgoing_packet)) != 0)
    #####: 2976:			return r;
        -: 2977:		/* sshbuf_dump(state->output, stderr); */
        -: 2978:	}
    #####: 2979:	sshbuf_reset(state->outgoing_packet);
    #####: 2980:	return 0;
        -: 2981:}
        -: 2982:
        -: 2983:/* send it */
        -: 2984:
        -: 2985:int
       92: 2986:sshpkt_send(struct ssh *ssh)
        -: 2987:{
       92: 2988:	if (ssh->state && ssh->state->mux)
    #####: 2989:		return ssh_packet_send_mux(ssh);
       92: 2990:	if (compat20)
       92: 2991:		return ssh_packet_send2(ssh);
        -: 2992:	else
    #####: 2993:		return ssh_packet_send1(ssh);
        -: 2994:}
        -: 2995:
        -: 2996:int
    #####: 2997:sshpkt_disconnect(struct ssh *ssh, const char *fmt,...)
        -: 2998:{
        -: 2999:	char buf[1024];
        -: 3000:	va_list args;
        -: 3001:	int r;
        -: 3002:
    #####: 3003:	va_start(args, fmt);
    #####: 3004:	vsnprintf(buf, sizeof(buf), fmt, args);
    #####: 3005:	va_end(args);
        -: 3006:
    #####: 3007:	if (compat20) {
    #####: 3008:		if ((r = sshpkt_start(ssh, SSH2_MSG_DISCONNECT)) != 0 ||
    #####: 3009:		    (r = sshpkt_put_u32(ssh, SSH2_DISCONNECT_PROTOCOL_ERROR)) != 0 ||
    #####: 3010:		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
    #####: 3011:		    (r = sshpkt_put_cstring(ssh, "")) != 0 ||
        -: 3012:		    (r = sshpkt_send(ssh)) != 0)
    #####: 3013:			return r;
        -: 3014:	} else {
    #####: 3015:		if ((r = sshpkt_start(ssh, SSH_MSG_DISCONNECT)) != 0 ||
    #####: 3016:		    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||
        -: 3017:		    (r = sshpkt_send(ssh)) != 0)
    #####: 3018:			return r;
        -: 3019:	}
    #####: 3020:	return 0;
        -: 3021:}
        -: 3022:
        -: 3023:/* roundup current message to pad bytes */
        -: 3024:int
    #####: 3025:sshpkt_add_padding(struct ssh *ssh, u_char pad)
        -: 3026:{
    #####: 3027:	ssh->state->extra_pad = pad;
    #####: 3028:	return 0;
        -: 3029:}
