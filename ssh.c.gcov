        -:    0:Source:ssh.c
        -:    0:Graph:./ssh.gcno
        -:    0:Data:./ssh.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:/* $OpenBSD: ssh.c,v 1.448 2016/12/06 07:48:01 djm Exp $ */
        -:    2:/*
        -:    3: * Author: Tatu Ylonen <ylo@cs.hut.fi>
        -:    4: * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
        -:    5: *                    All rights reserved
        -:    6: * Ssh client program.  This program can be used to log into a remote machine.
        -:    7: * The software supports strong authentication, encryption, and forwarding
        -:    8: * of X11, TCP/IP, and authentication connections.
        -:    9: *
        -:   10: * As far as I am concerned, the code I have written for this software
        -:   11: * can be used freely for any purpose.  Any derived versions of this
        -:   12: * software must be clearly marked as such, and if the derived work is
        -:   13: * incompatible with the protocol description in the RFC file, it must be
        -:   14: * called by a name other than "ssh" or "Secure Shell".
        -:   15: *
        -:   16: * Copyright (c) 1999 Niels Provos.  All rights reserved.
        -:   17: * Copyright (c) 2000, 2001, 2002, 2003 Markus Friedl.  All rights reserved.
        -:   18: *
        -:   19: * Modified to work with SSL by Niels Provos <provos@citi.umich.edu>
        -:   20: * in Canada (German citizen).
        -:   21: *
        -:   22: * Redistribution and use in source and binary forms, with or without
        -:   23: * modification, are permitted provided that the following conditions
        -:   24: * are met:
        -:   25: * 1. Redistributions of source code must retain the above copyright
        -:   26: *    notice, this list of conditions and the following disclaimer.
        -:   27: * 2. Redistributions in binary form must reproduce the above copyright
        -:   28: *    notice, this list of conditions and the following disclaimer in the
        -:   29: *    documentation and/or other materials provided with the distribution.
        -:   30: *
        -:   31: * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
        -:   32: * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
        -:   33: * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   34: * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
        -:   35: * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
        -:   36: * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   37: * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   38: * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   39: * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
        -:   40: * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   41: */
        -:   42:
        -:   43:#include "includes.h"
        -:   44:
        -:   45:#include <sys/types.h>
        -:   46:#ifdef HAVE_SYS_STAT_H
        -:   47:# include <sys/stat.h>
        -:   48:#endif
        -:   49:#include <sys/resource.h>
        -:   50:#include <sys/ioctl.h>
        -:   51:#include <sys/socket.h>
        -:   52:#include <sys/wait.h>
        -:   53:
        -:   54:#include <ctype.h>
        -:   55:#include <errno.h>
        -:   56:#include <fcntl.h>
        -:   57:#include <netdb.h>
        -:   58:#ifdef HAVE_PATHS_H
        -:   59:#include <paths.h>
        -:   60:#endif
        -:   61:#include <pwd.h>
        -:   62:#include <signal.h>
        -:   63:#include <stdarg.h>
        -:   64:#include <stddef.h>
        -:   65:#include <stdio.h>
        -:   66:#include <stdlib.h>
        -:   67:#include <string.h>
        -:   68:#include <unistd.h>
        -:   69:#include <limits.h>
        -:   70:#include <locale.h>
        -:   71:
        -:   72:#include <netinet/in.h>
        -:   73:#include <arpa/inet.h>
        -:   74:
        -:   75:#ifdef WITH_OPENSSL
        -:   76:#include <openssl/evp.h>
        -:   77:#include <openssl/err.h>
        -:   78:#endif
        -:   79:#include "openbsd-compat/openssl-compat.h"
        -:   80:#include "openbsd-compat/sys-queue.h"
        -:   81:
        -:   82:#include "xmalloc.h"
        -:   83:#include "ssh.h"
        -:   84:#include "ssh1.h"
        -:   85:#include "ssh2.h"
        -:   86:#include "canohost.h"
        -:   87:#include "compat.h"
        -:   88:#include "cipher.h"
        -:   89:#include "digest.h"
        -:   90:#include "packet.h"
        -:   91:#include "buffer.h"
        -:   92:#include "channels.h"
        -:   93:#include "key.h"
        -:   94:#include "authfd.h"
        -:   95:#include "authfile.h"
        -:   96:#include "pathnames.h"
        -:   97:#include "dispatch.h"
        -:   98:#include "clientloop.h"
        -:   99:#include "log.h"
        -:  100:#include "misc.h"
        -:  101:#include "readconf.h"
        -:  102:#include "sshconnect.h"
        -:  103:#include "kex.h"
        -:  104:#include "mac.h"
        -:  105:#include "sshpty.h"
        -:  106:#include "match.h"
        -:  107:#include "msg.h"
        -:  108:#include "uidswap.h"
        -:  109:#include "version.h"
        -:  110:#include "ssherr.h"
        -:  111:#include "myproposal.h"
        -:  112:#include "utf8.h"
        -:  113:
        -:  114:#ifdef ENABLE_PKCS11
        -:  115:#include "ssh-pkcs11.h"
        -:  116:#endif
        -:  117:
        -:  118:extern char *__progname;
        -:  119:
        -:  120:/* Saves a copy of argv for setproctitle emulation */
        -:  121:#ifndef HAVE_SETPROCTITLE
        -:  122:static char **saved_av;
        -:  123:#endif
        -:  124:
        -:  125:/* Flag indicating whether debug mode is on.  May be set on the command line. */
        -:  126:int debug_flag = 0;
        -:  127:
        -:  128:/* Flag indicating whether a tty should be requested */
        -:  129:int tty_flag = 0;
        -:  130:
        -:  131:/* don't exec a shell */
        -:  132:int no_shell_flag = 0;
        -:  133:
        -:  134:/*
        -:  135: * Flag indicating that nothing should be read from stdin.  This can be set
        -:  136: * on the command line.
        -:  137: */
        -:  138:int stdin_null_flag = 0;
        -:  139:
        -:  140:/*
        -:  141: * Flag indicating that the current process should be backgrounded and
        -:  142: * a new slave launched in the foreground for ControlPersist.
        -:  143: */
        -:  144:int need_controlpersist_detach = 0;
        -:  145:
        -:  146:/* Copies of flags for ControlPersist foreground slave */
        -:  147:int ostdin_null_flag, ono_shell_flag, otty_flag, orequest_tty;
        -:  148:
        -:  149:/*
        -:  150: * Flag indicating that ssh should fork after authentication.  This is useful
        -:  151: * so that the passphrase can be entered manually, and then ssh goes to the
        -:  152: * background.
        -:  153: */
        -:  154:int fork_after_authentication_flag = 0;
        -:  155:
        -:  156:/*
        -:  157: * General data structure for command line options and options configurable
        -:  158: * in configuration files.  See readconf.h.
        -:  159: */
        -:  160:Options options;
        -:  161:
        -:  162:/* optional user configfile */
        -:  163:char *config = NULL;
        -:  164:
        -:  165:/*
        -:  166: * Name of the host we are connecting to.  This is the name given on the
        -:  167: * command line, or the HostName specified for the user-supplied name in a
        -:  168: * configuration file.
        -:  169: */
        -:  170:char *host;
        -:  171:
        -:  172:/* socket address the host resolves to */
        -:  173:struct sockaddr_storage hostaddr;
        -:  174:
        -:  175:/* Private host keys. */
        -:  176:Sensitive sensitive_data;
        -:  177:
        -:  178:/* Original real UID. */
        -:  179:uid_t original_real_uid;
        -:  180:uid_t original_effective_uid;
        -:  181:
        -:  182:/* command to be executed */
        -:  183:Buffer command;
        -:  184:
        -:  185:/* Should we execute a command or invoke a subsystem? */
        -:  186:int subsystem_flag = 0;
        -:  187:
        -:  188:/* # of replies received for global requests */
        -:  189:static int remote_forward_confirms_received = 0;
        -:  190:
        -:  191:/* mux.c */
        -:  192:extern int muxserver_sock;
        -:  193:extern u_int muxclient_command;
        -:  194:
        -:  195:/* Prints a help message to the user.  This function never returns. */
        -:  196:
        -:  197:static void
    #####:  198:usage(void)
        -:  199:{
    #####:  200:	fprintf(stderr,
        -:  201:"usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n"
        -:  202:"           [-D [bind_address:]port] [-E log_file] [-e escape_char]\n"
        -:  203:"           [-F configfile] [-I pkcs11] [-i identity_file]\n"
        -:  204:"           [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]\n"
        -:  205:"           [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]\n"
        -:  206:"           [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]\n"
        -:  207:"           [user@]hostname [command]\n"
        -:  208:	);
    #####:  209:	exit(255);
        -:  210:}
        -:  211:
        -:  212:static int ssh_session(void);
        -:  213:static int ssh_session2(void);
        -:  214:static void load_public_identity_files(void);
        -:  215:static void main_sigchld_handler(int);
        -:  216:
        -:  217:/* ~/ expand a list of paths. NB. assumes path[n] is heap-allocated. */
        -:  218:static void
        4:  219:tilde_expand_paths(char **paths, u_int num_paths)
        -:  220:{
        -:  221:	u_int i;
        -:  222:	char *cp;
        -:  223:
       12:  224:	for (i = 0; i < num_paths; i++) {
        8:  225:		cp = tilde_expand_filename(paths[i], original_real_uid);
        8:  226:		free(paths[i]);
        8:  227:		paths[i] = cp;
        -:  228:	}
        4:  229:}
        -:  230:
        -:  231:/*
        -:  232: * Attempt to resolve a host name / port to a set of addresses and
        -:  233: * optionally return any CNAMEs encountered along the way.
        -:  234: * Returns NULL on failure.
        -:  235: * NB. this function must operate with a options having undefined members.
        -:  236: */
        -:  237:static struct addrinfo *
        2:  238:resolve_host(const char *name, int port, int logerr, char *cname, size_t clen)
        -:  239:{
        -:  240:	char strport[NI_MAXSERV];
        -:  241:	struct addrinfo hints, *res;
        2:  242:	int gaierr, loglevel = SYSLOG_LEVEL_DEBUG1;
        -:  243:
        2:  244:	if (port <= 0)
    #####:  245:		port = default_ssh_port();
        -:  246:
        2:  247:	snprintf(strport, sizeof strport, "%d", port);
        2:  248:	memset(&hints, 0, sizeof(hints));
        4:  249:	hints.ai_family = options.address_family == -1 ?
        2:  250:	    AF_UNSPEC : options.address_family;
        2:  251:	hints.ai_socktype = SOCK_STREAM;
        2:  252:	if (cname != NULL)
        2:  253:		hints.ai_flags = AI_CANONNAME;
        2:  254:	if ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {
    #####:  255:		if (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))
    #####:  256:			loglevel = SYSLOG_LEVEL_ERROR;
    #####:  257:		do_log2(loglevel, "%s: Could not resolve hostname %.100s: %s",
        -:  258:		    __progname, name, ssh_gai_strerror(gaierr));
    #####:  259:		return NULL;
        -:  260:	}
        2:  261:	if (cname != NULL && res->ai_canonname != NULL) {
        2:  262:		if (strlcpy(cname, res->ai_canonname, clen) >= clen) {
    #####:  263:			error("%s: host \"%s\" cname \"%s\" too long (max %lu)",
    #####:  264:			    __func__, name,  res->ai_canonname, (u_long)clen);
    #####:  265:			if (clen > 0)
    #####:  266:				*cname = '\0';
        -:  267:		}
        -:  268:	}
        2:  269:	return res;
        -:  270:}
        -:  271:
        -:  272:/*
        -:  273: * Attempt to resolve a numeric host address / port to a single address.
        -:  274: * Returns a canonical address string.
        -:  275: * Returns NULL on failure.
        -:  276: * NB. this function must operate with a options having undefined members.
        -:  277: */
        -:  278:static struct addrinfo *
    #####:  279:resolve_addr(const char *name, int port, char *caddr, size_t clen)
        -:  280:{
        -:  281:	char addr[NI_MAXHOST], strport[NI_MAXSERV];
        -:  282:	struct addrinfo hints, *res;
        -:  283:	int gaierr;
        -:  284:
    #####:  285:	if (port <= 0)
    #####:  286:		port = default_ssh_port();
    #####:  287:	snprintf(strport, sizeof strport, "%u", port);
    #####:  288:	memset(&hints, 0, sizeof(hints));
    #####:  289:	hints.ai_family = options.address_family == -1 ?
    #####:  290:	    AF_UNSPEC : options.address_family;
    #####:  291:	hints.ai_socktype = SOCK_STREAM;
    #####:  292:	hints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;
    #####:  293:	if ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {
    #####:  294:		debug2("%s: could not resolve name %.100s as address: %s",
        -:  295:		    __func__, name, ssh_gai_strerror(gaierr));
    #####:  296:		return NULL;
        -:  297:	}
    #####:  298:	if (res == NULL) {
    #####:  299:		debug("%s: getaddrinfo %.100s returned no addresses",
        -:  300:		 __func__, name);
    #####:  301:		return NULL;
        -:  302:	}
    #####:  303:	if (res->ai_next != NULL) {
    #####:  304:		debug("%s: getaddrinfo %.100s returned multiple addresses",
        -:  305:		    __func__, name);
    #####:  306:		goto fail;
        -:  307:	}
    #####:  308:	if ((gaierr = getnameinfo(res->ai_addr, res->ai_addrlen,
        -:  309:	    addr, sizeof(addr), NULL, 0, NI_NUMERICHOST)) != 0) {
    #####:  310:		debug("%s: Could not format address for name %.100s: %s",
        -:  311:		    __func__, name, ssh_gai_strerror(gaierr));
    #####:  312:		goto fail;
        -:  313:	}
    #####:  314:	if (strlcpy(caddr, addr, clen) >= clen) {
    #####:  315:		error("%s: host \"%s\" addr \"%s\" too long (max %lu)",
        -:  316:		    __func__, name,  addr, (u_long)clen);
    #####:  317:		if (clen > 0)
    #####:  318:			*caddr = '\0';
        -:  319: fail:
    #####:  320:		freeaddrinfo(res);
    #####:  321:		return NULL;
        -:  322:	}
    #####:  323:	return res;
        -:  324:}
        -:  325:
        -:  326:/*
        -:  327: * Check whether the cname is a permitted replacement for the hostname
        -:  328: * and perform the replacement if it is.
        -:  329: * NB. this function must operate with a options having undefined members.
        -:  330: */
        -:  331:static int
    #####:  332:check_follow_cname(int direct, char **namep, const char *cname)
        -:  333:{
        -:  334:	int i;
        -:  335:	struct allowed_cname *rule;
        -:  336:
    #####:  337:	if (*cname == '\0' || options.num_permitted_cnames == 0 ||
    #####:  338:	    strcmp(*namep, cname) == 0)
    #####:  339:		return 0;
    #####:  340:	if (options.canonicalize_hostname == SSH_CANONICALISE_NO)
    #####:  341:		return 0;
        -:  342:	/*
        -:  343:	 * Don't attempt to canonicalize names that will be interpreted by
        -:  344:	 * a proxy or jump host unless the user specifically requests so.
        -:  345:	 */
    #####:  346:	if (!direct &&
    #####:  347:	    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)
    #####:  348:		return 0;
    #####:  349:	debug3("%s: check \"%s\" CNAME \"%s\"", __func__, *namep, cname);
    #####:  350:	for (i = 0; i < options.num_permitted_cnames; i++) {
    #####:  351:		rule = options.permitted_cnames + i;
    #####:  352:		if (match_pattern_list(*namep, rule->source_list, 1) != 1 ||
    #####:  353:		    match_pattern_list(cname, rule->target_list, 1) != 1)
    #####:  354:			continue;
    #####:  355:		verbose("Canonicalized DNS aliased hostname "
        -:  356:		    "\"%s\" => \"%s\"", *namep, cname);
    #####:  357:		free(*namep);
    #####:  358:		*namep = xstrdup(cname);
    #####:  359:		return 1;
        -:  360:	}
    #####:  361:	return 0;
        -:  362:}
        -:  363:
        -:  364:/*
        -:  365: * Attempt to resolve the supplied hostname after applying the user's
        -:  366: * canonicalization rules. Returns the address list for the host or NULL
        -:  367: * if no name was found after canonicalization.
        -:  368: * NB. this function must operate with a options having undefined members.
        -:  369: */
        -:  370:static struct addrinfo *
    #####:  371:resolve_canonicalize(char **hostp, int port)
        -:  372:{
        -:  373:	int i, direct, ndots;
        -:  374:	char *cp, *fullhost, newname[NI_MAXHOST];
        -:  375:	struct addrinfo *addrs;
        -:  376:
    #####:  377:	if (options.canonicalize_hostname == SSH_CANONICALISE_NO)
    #####:  378:		return NULL;
        -:  379:
        -:  380:	/*
        -:  381:	 * Don't attempt to canonicalize names that will be interpreted by
        -:  382:	 * a proxy unless the user specifically requests so.
        -:  383:	 */
    #####:  384:	direct = option_clear_or_none(options.proxy_command) &&
    #####:  385:	    options.jump_host == NULL;
    #####:  386:	if (!direct &&
    #####:  387:	    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)
    #####:  388:		return NULL;
        -:  389:
        -:  390:	/* Try numeric hostnames first */
    #####:  391:	if ((addrs = resolve_addr(*hostp, port,
        -:  392:	    newname, sizeof(newname))) != NULL) {
    #####:  393:		debug2("%s: hostname %.100s is address", __func__, *hostp);
    #####:  394:		if (strcasecmp(*hostp, newname) != 0) {
    #####:  395:			debug2("%s: canonicalised address \"%s\" => \"%s\"",
        -:  396:			    __func__, *hostp, newname);
    #####:  397:			free(*hostp);
    #####:  398:			*hostp = xstrdup(newname);
        -:  399:		}
    #####:  400:		return addrs;
        -:  401:	}
        -:  402:
        -:  403:	/* If domain name is anchored, then resolve it now */
    #####:  404:	if ((*hostp)[strlen(*hostp) - 1] == '.') {
    #####:  405:		debug3("%s: name is fully qualified", __func__);
    #####:  406:		fullhost = xstrdup(*hostp);
    #####:  407:		if ((addrs = resolve_host(fullhost, port, 0,
        -:  408:		    newname, sizeof(newname))) != NULL)
    #####:  409:			goto found;
    #####:  410:		free(fullhost);
    #####:  411:		goto notfound;
        -:  412:	}
        -:  413:
        -:  414:	/* Don't apply canonicalization to sufficiently-qualified hostnames */
    #####:  415:	ndots = 0;
    #####:  416:	for (cp = *hostp; *cp != '\0'; cp++) {
    #####:  417:		if (*cp == '.')
    #####:  418:			ndots++;
        -:  419:	}
    #####:  420:	if (ndots > options.canonicalize_max_dots) {
    #####:  421:		debug3("%s: not canonicalizing hostname \"%s\" (max dots %d)",
        -:  422:		    __func__, *hostp, options.canonicalize_max_dots);
    #####:  423:		return NULL;
        -:  424:	}
        -:  425:	/* Attempt each supplied suffix */
    #####:  426:	for (i = 0; i < options.num_canonical_domains; i++) {
    #####:  427:		*newname = '\0';
    #####:  428:		xasprintf(&fullhost, "%s.%s.", *hostp,
        -:  429:		    options.canonical_domains[i]);
    #####:  430:		debug3("%s: attempting \"%s\" => \"%s\"", __func__,
        -:  431:		    *hostp, fullhost);
    #####:  432:		if ((addrs = resolve_host(fullhost, port, 0,
        -:  433:		    newname, sizeof(newname))) == NULL) {
    #####:  434:			free(fullhost);
    #####:  435:			continue;
        -:  436:		}
        -:  437: found:
        -:  438:		/* Remove trailing '.' */
    #####:  439:		fullhost[strlen(fullhost) - 1] = '\0';
        -:  440:		/* Follow CNAME if requested */
    #####:  441:		if (!check_follow_cname(direct, &fullhost, newname)) {
    #####:  442:			debug("Canonicalized hostname \"%s\" => \"%s\"",
        -:  443:			    *hostp, fullhost);
        -:  444:		}
    #####:  445:		free(*hostp);
    #####:  446:		*hostp = fullhost;
    #####:  447:		return addrs;
        -:  448:	}
        -:  449: notfound:
    #####:  450:	if (!options.canonicalize_fallback_local)
    #####:  451:		fatal("%s: Could not resolve host \"%s\"", __progname, *hostp);
    #####:  452:	debug2("%s: host %s not found in any suffix", __func__, *hostp);
    #####:  453:	return NULL;
        -:  454:}
        -:  455:
        -:  456:/*
        -:  457: * Read per-user configuration file.  Ignore the system wide config
        -:  458: * file if the user specifies a config file on the command line.
        -:  459: */
        -:  460:static void
        2:  461:process_config_files(const char *host_arg, struct passwd *pw, int post_canon)
        -:  462:{
        -:  463:	char buf[PATH_MAX];
        -:  464:	int r;
        -:  465:
        2:  466:	if (config != NULL) {
    #####:  467:		if (strcasecmp(config, "none") != 0 &&
    #####:  468:		    !read_config_file(config, pw, host, host_arg, &options,
        -:  469:		    SSHCONF_USERCONF | (post_canon ? SSHCONF_POSTCANON : 0)))
    #####:  470:			fatal("Can't open user config file %.100s: "
    #####:  471:			    "%.100s", config, strerror(errno));
        -:  472:	} else {
        2:  473:		r = snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir,
        -:  474:		    _PATH_SSH_USER_CONFFILE);
        2:  475:		if (r > 0 && (size_t)r < sizeof(buf))
        2:  476:			(void)read_config_file(buf, pw, host, host_arg,
        -:  477:			    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |
        -:  478:			    (post_canon ? SSHCONF_POSTCANON : 0));
        -:  479:
        -:  480:		/* Read systemwide configuration file after user config. */
        2:  481:		(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,
        -:  482:		    host, host_arg, &options,
        -:  483:		    post_canon ? SSHCONF_POSTCANON : 0);
        -:  484:	}
        2:  485:}
        -:  486:
        -:  487:/* Rewrite the port number in an addrinfo list of addresses */
        -:  488:static void
    #####:  489:set_addrinfo_port(struct addrinfo *addrs, int port)
        -:  490:{
        -:  491:	struct addrinfo *addr;
        -:  492:
    #####:  493:	for (addr = addrs; addr != NULL; addr = addr->ai_next) {
    #####:  494:		switch (addr->ai_family) {
        -:  495:		case AF_INET:
    #####:  496:			((struct sockaddr_in *)addr->ai_addr)->
    #####:  497:			    sin_port = htons(port);
    #####:  498:			break;
        -:  499:		case AF_INET6:
    #####:  500:			((struct sockaddr_in6 *)addr->ai_addr)->
    #####:  501:			    sin6_port = htons(port);
    #####:  502:			break;
        -:  503:		}
        -:  504:	}
    #####:  505:}
        -:  506:
        -:  507:/*
        -:  508: * Main program for the ssh client.
        -:  509: */
        -:  510:int
        2:  511:main(int ac, char **av)
        -:  512:{
        2:  513:	struct ssh *ssh = NULL;
        2:  514:	int i, r, opt, exit_status, use_syslog, direct, config_test = 0;
        -:  515:	char *p, *cp, *line, *argv0, buf[PATH_MAX], *host_arg, *logfile;
        -:  516:	char thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];
        -:  517:	char cname[NI_MAXHOST], uidstr[32], *conn_hash_hex;
        -:  518:	struct stat st;
        -:  519:	struct passwd *pw;
        -:  520:	int timeout_ms;
        -:  521:	extern int optind, optreset;
        -:  522:	extern char *optarg;
        -:  523:	struct Forward fwd;
        2:  524:	struct addrinfo *addrs = NULL;
        -:  525:	struct ssh_digest_ctx *md;
        -:  526:	u_char conn_hash[SSH_DIGEST_MAX_LENGTH];
        -:  527:
        2:  528:	ssh_malloc_init();	/* must be called before any mallocs */
        -:  529:	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
        2:  530:	sanitise_stdfd();
        -:  531:
        2:  532:	__progname = ssh_get_progname(av[0]);
        -:  533:
        -:  534:#ifndef HAVE_SETPROCTITLE
        -:  535:	/* Prepare for later setproctitle emulation */
        -:  536:	/* Save argv so it isn't clobbered by setproctitle() emulation */
        2:  537:	saved_av = xcalloc(ac + 1, sizeof(*saved_av));
        7:  538:	for (i = 0; i < ac; i++)
        5:  539:		saved_av[i] = xstrdup(av[i]);
        2:  540:	saved_av[i] = NULL;
        2:  541:	compat_init_setproctitle(ac, av);
        2:  542:	av = saved_av;
        -:  543:#endif
        -:  544:
        -:  545:	/*
        -:  546:	 * Discard other fds that are hanging around. These can cause problem
        -:  547:	 * with backgrounded ssh processes started by ControlPersist.
        -:  548:	 */
        2:  549:	closefrom(STDERR_FILENO + 1);
        -:  550:
        -:  551:	/*
        -:  552:	 * Save the original real uid.  It will be needed later (uid-swapping
        -:  553:	 * may clobber the real uid).
        -:  554:	 */
        2:  555:	original_real_uid = getuid();
        2:  556:	original_effective_uid = geteuid();
        -:  557:
        -:  558:	/*
        -:  559:	 * Use uid-swapping to give up root privileges for the duration of
        -:  560:	 * option processing.  We will re-instantiate the rights when we are
        -:  561:	 * ready to create the privileged port, and will permanently drop
        -:  562:	 * them when the port has been created (actually, when the connection
        -:  563:	 * has been made, as we may need to create the port several times).
        -:  564:	 */
        2:  565:	PRIV_END;
        -:  566:
        -:  567:#ifdef HAVE_SETRLIMIT
        -:  568:	/* If we are installed setuid root be careful to not drop core. */
        2:  569:	if (original_real_uid != original_effective_uid) {
        -:  570:		struct rlimit rlim;
    #####:  571:		rlim.rlim_cur = rlim.rlim_max = 0;
    #####:  572:		if (setrlimit(RLIMIT_CORE, &rlim) < 0)
    #####:  573:			fatal("setrlimit failed: %.100s", strerror(errno));
        -:  574:	}
        -:  575:#endif
        -:  576:	/* Get user data. */
        2:  577:	pw = getpwuid(original_real_uid);
        2:  578:	if (!pw) {
    #####:  579:		logit("No user exists for uid %lu", (u_long)original_real_uid);
    #####:  580:		exit(255);
        -:  581:	}
        -:  582:	/* Take a copy of the returned structure. */
        2:  583:	pw = pwcopy(pw);
        -:  584:
        -:  585:	/*
        -:  586:	 * Set our umask to something reasonable, as some files are created
        -:  587:	 * with the default umask.  This will make them world-readable but
        -:  588:	 * writable only by the owner, which is ok for all files for which we
        -:  589:	 * don't set the modes explicitly.
        -:  590:	 */
        2:  591:	umask(022);
        -:  592:
        2:  593:	msetlocale();
        -:  594:
        -:  595:	/*
        -:  596:	 * Initialize option structure to indicate that no values have been
        -:  597:	 * set.
        -:  598:	 */
        2:  599:	initialize_options(&options);
        -:  600:
        -:  601:	/* Parse command-line arguments. */
        2:  602:	host = NULL;
        2:  603:	use_syslog = 0;
        2:  604:	logfile = NULL;
        2:  605:	argv0 = av[0];
        -:  606:
        -:  607: again:
        5:  608:	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx"
        -:  609:	    "ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
        1:  610:		switch (opt) {
        -:  611:		case '1':
    #####:  612:			options.protocol = SSH_PROTO_1;
    #####:  613:			break;
        -:  614:		case '2':
    #####:  615:			options.protocol = SSH_PROTO_2;
    #####:  616:			break;
        -:  617:		case '4':
    #####:  618:			options.address_family = AF_INET;
    #####:  619:			break;
        -:  620:		case '6':
    #####:  621:			options.address_family = AF_INET6;
    #####:  622:			break;
        -:  623:		case 'n':
    #####:  624:			stdin_null_flag = 1;
    #####:  625:			break;
        -:  626:		case 'f':
    #####:  627:			fork_after_authentication_flag = 1;
    #####:  628:			stdin_null_flag = 1;
    #####:  629:			break;
        -:  630:		case 'x':
    #####:  631:			options.forward_x11 = 0;
    #####:  632:			break;
        -:  633:		case 'X':
    #####:  634:			options.forward_x11 = 1;
    #####:  635:			break;
        -:  636:		case 'y':
    #####:  637:			use_syslog = 1;
    #####:  638:			break;
        -:  639:		case 'E':
    #####:  640:			logfile = optarg;
    #####:  641:			break;
        -:  642:		case 'G':
    #####:  643:			config_test = 1;
    #####:  644:			break;
        -:  645:		case 'Y':
    #####:  646:			options.forward_x11 = 1;
    #####:  647:			options.forward_x11_trusted = 1;
    #####:  648:			break;
        -:  649:		case 'g':
    #####:  650:			options.fwd_opts.gateway_ports = 1;
    #####:  651:			break;
        -:  652:		case 'O':
    #####:  653:			if (options.stdio_forward_host != NULL)
    #####:  654:				fatal("Cannot specify multiplexing "
        -:  655:				    "command with -W");
    #####:  656:			else if (muxclient_command != 0)
    #####:  657:				fatal("Multiplexing command already specified");
    #####:  658:			if (strcmp(optarg, "check") == 0)
    #####:  659:				muxclient_command = SSHMUX_COMMAND_ALIVE_CHECK;
    #####:  660:			else if (strcmp(optarg, "forward") == 0)
    #####:  661:				muxclient_command = SSHMUX_COMMAND_FORWARD;
    #####:  662:			else if (strcmp(optarg, "exit") == 0)
    #####:  663:				muxclient_command = SSHMUX_COMMAND_TERMINATE;
    #####:  664:			else if (strcmp(optarg, "stop") == 0)
    #####:  665:				muxclient_command = SSHMUX_COMMAND_STOP;
    #####:  666:			else if (strcmp(optarg, "cancel") == 0)
    #####:  667:				muxclient_command = SSHMUX_COMMAND_CANCEL_FWD;
    #####:  668:			else if (strcmp(optarg, "proxy") == 0)
    #####:  669:				muxclient_command = SSHMUX_COMMAND_PROXY;
        -:  670:			else
    #####:  671:				fatal("Invalid multiplex command.");
    #####:  672:			break;
        -:  673:		case 'P':	/* deprecated */
    #####:  674:			options.use_privileged_port = 0;
    #####:  675:			break;
        -:  676:		case 'Q':
    #####:  677:			cp = NULL;
    #####:  678:			if (strcmp(optarg, "cipher") == 0)
    #####:  679:				cp = cipher_alg_list('\n', 0);
    #####:  680:			else if (strcmp(optarg, "cipher-auth") == 0)
    #####:  681:				cp = cipher_alg_list('\n', 1);
    #####:  682:			else if (strcmp(optarg, "mac") == 0)
    #####:  683:				cp = mac_alg_list('\n');
    #####:  684:			else if (strcmp(optarg, "kex") == 0)
    #####:  685:				cp = kex_alg_list('\n');
    #####:  686:			else if (strcmp(optarg, "key") == 0)
    #####:  687:				cp = sshkey_alg_list(0, 0, '\n');
    #####:  688:			else if (strcmp(optarg, "key-cert") == 0)
    #####:  689:				cp = sshkey_alg_list(1, 0, '\n');
    #####:  690:			else if (strcmp(optarg, "key-plain") == 0)
    #####:  691:				cp = sshkey_alg_list(0, 1, '\n');
    #####:  692:			else if (strcmp(optarg, "protocol-version") == 0) {
        -:  693:#ifdef WITH_SSH1
        -:  694:				cp = xstrdup("1\n2");
        -:  695:#else
    #####:  696:				cp = xstrdup("2");
        -:  697:#endif
        -:  698:			}
    #####:  699:			if (cp == NULL)
    #####:  700:				fatal("Unsupported query \"%s\"", optarg);
    #####:  701:			printf("%s\n", cp);
    #####:  702:			free(cp);
    #####:  703:			exit(0);
        -:  704:			break;
        -:  705:		case 'a':
    #####:  706:			options.forward_agent = 0;
    #####:  707:			break;
        -:  708:		case 'A':
    #####:  709:			options.forward_agent = 1;
    #####:  710:			break;
        -:  711:		case 'k':
    #####:  712:			options.gss_deleg_creds = 0;
    #####:  713:			break;
        -:  714:		case 'K':
    #####:  715:			options.gss_authentication = 1;
    #####:  716:			options.gss_deleg_creds = 1;
    #####:  717:			break;
        -:  718:		case 'i':
    #####:  719:			p = tilde_expand_filename(optarg, original_real_uid);
    #####:  720:			if (stat(p, &st) < 0)
    #####:  721:				fprintf(stderr, "Warning: Identity file %s "
        -:  722:				    "not accessible: %s.\n", p,
    #####:  723:				    strerror(errno));
        -:  724:			else
    #####:  725:				add_identity_file(&options, NULL, p, 1);
    #####:  726:			free(p);
    #####:  727:			break;
        -:  728:		case 'I':
        -:  729:#ifdef ENABLE_PKCS11
    #####:  730:			free(options.pkcs11_provider);
    #####:  731:			options.pkcs11_provider = xstrdup(optarg);
        -:  732:#else
        -:  733:			fprintf(stderr, "no support for PKCS#11.\n");
        -:  734:#endif
    #####:  735:			break;
        -:  736:		case 'J':
    #####:  737:			if (options.jump_host != NULL)
    #####:  738:				fatal("Only a single -J option permitted");
    #####:  739:			if (options.proxy_command != NULL)
    #####:  740:				fatal("Cannot specify -J with ProxyCommand");
    #####:  741:			if (parse_jump(optarg, &options, 1) == -1)
    #####:  742:				fatal("Invalid -J argument");
    #####:  743:			options.proxy_command = xstrdup("none");
    #####:  744:			break;
        -:  745:		case 't':
    #####:  746:			if (options.request_tty == REQUEST_TTY_YES)
    #####:  747:				options.request_tty = REQUEST_TTY_FORCE;
        -:  748:			else
    #####:  749:				options.request_tty = REQUEST_TTY_YES;
    #####:  750:			break;
        -:  751:		case 'v':
        1:  752:			if (debug_flag == 0) {
        1:  753:				debug_flag = 1;
        1:  754:				options.log_level = SYSLOG_LEVEL_DEBUG1;
        -:  755:			} else {
    #####:  756:				if (options.log_level < SYSLOG_LEVEL_DEBUG3) {
    #####:  757:					debug_flag++;
    #####:  758:					options.log_level++;
        -:  759:				}
        -:  760:			}
        1:  761:			break;
        -:  762:		case 'V':
    #####:  763:			fprintf(stderr, "%s, %s\n",
        -:  764:			    SSH_RELEASE,
        -:  765:#ifdef WITH_OPENSSL
        -:  766:			    SSLeay_version(SSLEAY_VERSION)
        -:  767:#else
        -:  768:			    "without OpenSSL"
        -:  769:#endif
        -:  770:			);
    #####:  771:			if (opt == 'V')
    #####:  772:				exit(0);
    #####:  773:			break;
        -:  774:		case 'w':
    #####:  775:			if (options.tun_open == -1)
    #####:  776:				options.tun_open = SSH_TUNMODE_DEFAULT;
    #####:  777:			options.tun_local = a2tun(optarg, &options.tun_remote);
    #####:  778:			if (options.tun_local == SSH_TUNID_ERR) {
    #####:  779:				fprintf(stderr,
        -:  780:				    "Bad tun device '%s'\n", optarg);
    #####:  781:				exit(255);
        -:  782:			}
    #####:  783:			break;
        -:  784:		case 'W':
    #####:  785:			if (options.stdio_forward_host != NULL)
    #####:  786:				fatal("stdio forward already specified");
    #####:  787:			if (muxclient_command != 0)
    #####:  788:				fatal("Cannot specify stdio forward with -O");
    #####:  789:			if (parse_forward(&fwd, optarg, 1, 0)) {
    #####:  790:				options.stdio_forward_host = fwd.listen_host;
    #####:  791:				options.stdio_forward_port = fwd.listen_port;
    #####:  792:				free(fwd.connect_host);
        -:  793:			} else {
    #####:  794:				fprintf(stderr,
        -:  795:				    "Bad stdio forwarding specification '%s'\n",
        -:  796:				    optarg);
    #####:  797:				exit(255);
        -:  798:			}
    #####:  799:			options.request_tty = REQUEST_TTY_NO;
    #####:  800:			no_shell_flag = 1;
    #####:  801:			break;
        -:  802:		case 'q':
    #####:  803:			options.log_level = SYSLOG_LEVEL_QUIET;
    #####:  804:			break;
        -:  805:		case 'e':
    #####:  806:			if (optarg[0] == '^' && optarg[2] == 0 &&
    #####:  807:			    (u_char) optarg[1] >= 64 &&
    #####:  808:			    (u_char) optarg[1] < 128)
    #####:  809:				options.escape_char = (u_char) optarg[1] & 31;
    #####:  810:			else if (strlen(optarg) == 1)
    #####:  811:				options.escape_char = (u_char) optarg[0];
    #####:  812:			else if (strcmp(optarg, "none") == 0)
    #####:  813:				options.escape_char = SSH_ESCAPECHAR_NONE;
        -:  814:			else {
    #####:  815:				fprintf(stderr, "Bad escape character '%s'.\n",
        -:  816:				    optarg);
    #####:  817:				exit(255);
        -:  818:			}
    #####:  819:			break;
        -:  820:		case 'c':
    #####:  821:			if (ciphers_valid(*optarg == '+' ?
    #####:  822:			    optarg + 1 : optarg)) {
        -:  823:				/* SSH2 only */
    #####:  824:				free(options.ciphers);
    #####:  825:				options.ciphers = xstrdup(optarg);
    #####:  826:				options.cipher = SSH_CIPHER_INVALID;
    #####:  827:				break;
        -:  828:			}
        -:  829:			/* SSH1 only */
    #####:  830:			options.cipher = cipher_number(optarg);
    #####:  831:			if (options.cipher == -1) {
    #####:  832:				fprintf(stderr, "Unknown cipher type '%s'\n",
        -:  833:				    optarg);
    #####:  834:				exit(255);
        -:  835:			}
    #####:  836:			if (options.cipher == SSH_CIPHER_3DES)
    #####:  837:				options.ciphers = xstrdup("3des-cbc");
    #####:  838:			else if (options.cipher == SSH_CIPHER_BLOWFISH)
    #####:  839:				options.ciphers = xstrdup("blowfish-cbc");
        -:  840:			else
    #####:  841:				options.ciphers = xstrdup(KEX_CLIENT_ENCRYPT);
    #####:  842:			break;
        -:  843:		case 'm':
    #####:  844:			if (mac_valid(optarg)) {
    #####:  845:				free(options.macs);
    #####:  846:				options.macs = xstrdup(optarg);
        -:  847:			} else {
    #####:  848:				fprintf(stderr, "Unknown mac type '%s'\n",
        -:  849:				    optarg);
    #####:  850:				exit(255);
        -:  851:			}
    #####:  852:			break;
        -:  853:		case 'M':
    #####:  854:			if (options.control_master == SSHCTL_MASTER_YES)
    #####:  855:				options.control_master = SSHCTL_MASTER_ASK;
        -:  856:			else
    #####:  857:				options.control_master = SSHCTL_MASTER_YES;
    #####:  858:			break;
        -:  859:		case 'p':
    #####:  860:			options.port = a2port(optarg);
    #####:  861:			if (options.port <= 0) {
    #####:  862:				fprintf(stderr, "Bad port '%s'\n", optarg);
    #####:  863:				exit(255);
        -:  864:			}
    #####:  865:			break;
        -:  866:		case 'l':
    #####:  867:			options.user = optarg;
    #####:  868:			break;
        -:  869:
        -:  870:		case 'L':
    #####:  871:			if (parse_forward(&fwd, optarg, 0, 0))
    #####:  872:				add_local_forward(&options, &fwd);
        -:  873:			else {
    #####:  874:				fprintf(stderr,
        -:  875:				    "Bad local forwarding specification '%s'\n",
        -:  876:				    optarg);
    #####:  877:				exit(255);
        -:  878:			}
    #####:  879:			break;
        -:  880:
        -:  881:		case 'R':
    #####:  882:			if (parse_forward(&fwd, optarg, 0, 1)) {
    #####:  883:				add_remote_forward(&options, &fwd);
        -:  884:			} else {
    #####:  885:				fprintf(stderr,
        -:  886:				    "Bad remote forwarding specification "
        -:  887:				    "'%s'\n", optarg);
    #####:  888:				exit(255);
        -:  889:			}
    #####:  890:			break;
        -:  891:
        -:  892:		case 'D':
    #####:  893:			if (parse_forward(&fwd, optarg, 1, 0)) {
    #####:  894:				add_local_forward(&options, &fwd);
        -:  895:			} else {
    #####:  896:				fprintf(stderr,
        -:  897:				    "Bad dynamic forwarding specification "
        -:  898:				    "'%s'\n", optarg);
    #####:  899:				exit(255);
        -:  900:			}
    #####:  901:			break;
        -:  902:
        -:  903:		case 'C':
    #####:  904:			options.compression = 1;
    #####:  905:			break;
        -:  906:		case 'N':
    #####:  907:			no_shell_flag = 1;
    #####:  908:			options.request_tty = REQUEST_TTY_NO;
    #####:  909:			break;
        -:  910:		case 'T':
    #####:  911:			options.request_tty = REQUEST_TTY_NO;
    #####:  912:			break;
        -:  913:		case 'o':
    #####:  914:			line = xstrdup(optarg);
    #####:  915:			if (process_config_line(&options, pw,
    #####:  916:			    host ? host : "", host ? host : "", line,
        -:  917:			    "command-line", 0, NULL, SSHCONF_USERCONF) != 0)
    #####:  918:				exit(255);
    #####:  919:			free(line);
    #####:  920:			break;
        -:  921:		case 's':
    #####:  922:			subsystem_flag = 1;
    #####:  923:			break;
        -:  924:		case 'S':
    #####:  925:			free(options.control_path);
    #####:  926:			options.control_path = xstrdup(optarg);
    #####:  927:			break;
        -:  928:		case 'b':
    #####:  929:			options.bind_address = optarg;
    #####:  930:			break;
        -:  931:		case 'F':
    #####:  932:			config = optarg;
    #####:  933:			break;
        -:  934:		default:
    #####:  935:			usage();
        -:  936:		}
        -:  937:	}
        -:  938:
        2:  939:	ac -= optind;
        2:  940:	av += optind;
        -:  941:
        2:  942:	if (ac > 0 && !host) {
        2:  943:		if (strrchr(*av, '@')) {
        2:  944:			p = xstrdup(*av);
        2:  945:			cp = strrchr(p, '@');
        2:  946:			if (cp == NULL || cp == p)
    #####:  947:				usage();
        2:  948:			options.user = p;
        2:  949:			*cp = '\0';
        2:  950:			host = xstrdup(++cp);
        -:  951:		} else
    #####:  952:			host = xstrdup(*av);
        2:  953:		if (ac > 1) {
    #####:  954:			optind = optreset = 1;
    #####:  955:			goto again;
        -:  956:		}
        2:  957:		ac--, av++;
        -:  958:	}
        -:  959:
        -:  960:	/* Check that we got a host name. */
        2:  961:	if (!host)
    #####:  962:		usage();
        -:  963:
        2:  964:	host_arg = xstrdup(host);
        -:  965:
        -:  966:#ifdef WITH_OPENSSL
        2:  967:	OpenSSL_add_all_algorithms();
        2:  968:	ERR_load_crypto_strings();
        -:  969:#endif
        -:  970:
        -:  971:	/* Initialize the command to execute on remote host. */
        2:  972:	buffer_init(&command);
        -:  973:
        -:  974:	/*
        -:  975:	 * Save the command to execute on the remote host in a buffer. There
        -:  976:	 * is no limit on the length of the command, except by the maximum
        -:  977:	 * packet size.  Also sets the tty flag if there is no command.
        -:  978:	 */
        2:  979:	if (!ac) {
        -:  980:		/* No command specified - execute shell on a tty. */
        2:  981:		if (subsystem_flag) {
    #####:  982:			fprintf(stderr,
        -:  983:			    "You must specify a subsystem to invoke.\n");
    #####:  984:			usage();
        -:  985:		}
        -:  986:	} else {
        -:  987:		/* A command has been specified.  Store it into the buffer. */
    #####:  988:		for (i = 0; i < ac; i++) {
    #####:  989:			if (i)
    #####:  990:				buffer_append(&command, " ", 1);
    #####:  991:			buffer_append(&command, av[i], strlen(av[i]));
        -:  992:		}
        -:  993:	}
        -:  994:
        -:  995:	/* Cannot fork to background if no command. */
        2:  996:	if (fork_after_authentication_flag && buffer_len(&command) == 0 &&
    #####:  997:	    !no_shell_flag)
    #####:  998:		fatal("Cannot fork into background without a command "
        -:  999:		    "to execute.");
        -: 1000:
        -: 1001:	/*
        -: 1002:	 * Initialize "log" output.  Since we are the client all output
        -: 1003:	 * goes to stderr unless otherwise specified by -y or -E.
        -: 1004:	 */
        2: 1005:	if (use_syslog && logfile != NULL)
    #####: 1006:		fatal("Can't specify both -y and -E");
        2: 1007:	if (logfile != NULL)
    #####: 1008:		log_redirect_stderr_to(logfile);
        4: 1009:	log_init(argv0,
        2: 1010:	    options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
        -: 1011:	    SYSLOG_FACILITY_USER, !use_syslog);
        -: 1012:
        2: 1013:	if (debug_flag)
        1: 1014:		logit("%s, %s", SSH_RELEASE,
        -: 1015:#ifdef WITH_OPENSSL
        -: 1016:		    SSLeay_version(SSLEAY_VERSION)
        -: 1017:#else
        -: 1018:		    "without OpenSSL"
        -: 1019:#endif
        -: 1020:		);
        -: 1021:
        -: 1022:	/* Parse the configuration files */
        2: 1023:	process_config_files(host_arg, pw, 0);
        -: 1024:
        -: 1025:	/* Hostname canonicalisation needs a few options filled. */
        2: 1026:	fill_default_options_for_canonicalization(&options);
        -: 1027:
        -: 1028:	/* If the user has replaced the hostname then take it into use now */
        2: 1029:	if (options.hostname != NULL) {
        -: 1030:		/* NB. Please keep in sync with readconf.c:match_cfg_line() */
    #####: 1031:		cp = percent_expand(options.hostname,
        -: 1032:		    "h", host, (char *)NULL);
    #####: 1033:		free(host);
    #####: 1034:		host = cp;
    #####: 1035:		free(options.hostname);
    #####: 1036:		options.hostname = xstrdup(host);
        -: 1037:	}
        -: 1038:
        -: 1039:	/* If canonicalization requested then try to apply it */
        2: 1040:	lowercase(host);
        2: 1041:	if (options.canonicalize_hostname != SSH_CANONICALISE_NO)
    #####: 1042:		addrs = resolve_canonicalize(&host, options.port);
        -: 1043:
        -: 1044:	/*
        -: 1045:	 * If CanonicalizePermittedCNAMEs have been specified but
        -: 1046:	 * other canonicalization did not happen (by not being requested
        -: 1047:	 * or by failing with fallback) then the hostname may still be changed
        -: 1048:	 * as a result of CNAME following. 
        -: 1049:	 *
        -: 1050:	 * Try to resolve the bare hostname name using the system resolver's
        -: 1051:	 * usual search rules and then apply the CNAME follow rules.
        -: 1052:	 *
        -: 1053:	 * Skip the lookup if a ProxyCommand is being used unless the user
        -: 1054:	 * has specifically requested canonicalisation for this case via
        -: 1055:	 * CanonicalizeHostname=always
        -: 1056:	 */
        4: 1057:	direct = option_clear_or_none(options.proxy_command) &&
        2: 1058:	    options.jump_host == NULL;
        2: 1059:	if (addrs == NULL && options.num_permitted_cnames != 0 && (direct ||
    #####: 1060:	    options.canonicalize_hostname == SSH_CANONICALISE_ALWAYS)) {
    #####: 1061:		if ((addrs = resolve_host(host, options.port,
    #####: 1062:		    option_clear_or_none(options.proxy_command),
        -: 1063:		    cname, sizeof(cname))) == NULL) {
        -: 1064:			/* Don't fatal proxied host names not in the DNS */
    #####: 1065:			if (option_clear_or_none(options.proxy_command))
    #####: 1066:				cleanup_exit(255); /* logged in resolve_host */
        -: 1067:		} else
    #####: 1068:			check_follow_cname(direct, &host, cname);
        -: 1069:	}
        -: 1070:
        -: 1071:	/*
        -: 1072:	 * If canonicalisation is enabled then re-parse the configuration
        -: 1073:	 * files as new stanzas may match.
        -: 1074:	 */
        2: 1075:	if (options.canonicalize_hostname != 0) {
    #####: 1076:		debug("Re-reading configuration after hostname "
        -: 1077:		    "canonicalisation");
    #####: 1078:		free(options.hostname);
    #####: 1079:		options.hostname = xstrdup(host);
    #####: 1080:		process_config_files(host_arg, pw, 1);
        -: 1081:		/*
        -: 1082:		 * Address resolution happens early with canonicalisation
        -: 1083:		 * enabled and the port number may have changed since, so
        -: 1084:		 * reset it in address list
        -: 1085:		 */
    #####: 1086:		if (addrs != NULL && options.port > 0)
    #####: 1087:			set_addrinfo_port(addrs, options.port);
        -: 1088:	}
        -: 1089:
        -: 1090:	/* Fill configuration defaults. */
        2: 1091:	fill_default_options(&options);
        -: 1092:
        -: 1093:	/*
        -: 1094:	 * If ProxyJump option specified, then construct a ProxyCommand now.
        -: 1095:	 */
        2: 1096:	if (options.jump_host != NULL) {
        -: 1097:		char port_s[8];
        -: 1098:
        -: 1099:		/* Consistency check */
    #####: 1100:		if (options.proxy_command != NULL)
    #####: 1101:			fatal("inconsistent options: ProxyCommand+ProxyJump");
        -: 1102:		/* Never use FD passing for ProxyJump */
    #####: 1103:		options.proxy_use_fdpass = 0;
    #####: 1104:		snprintf(port_s, sizeof(port_s), "%d", options.jump_port);
    #####: 1105:		xasprintf(&options.proxy_command,
        -: 1106:		    "ssh%s%s%s%s%s%s%s%s%s%.*s -W %%h:%%p %s",
        -: 1107:		    /* Optional "-l user" argument if jump_user set */
    #####: 1108:		    options.jump_user == NULL ? "" : " -l ",
    #####: 1109:		    options.jump_user == NULL ? "" : options.jump_user,
        -: 1110:		    /* Optional "-p port" argument if jump_port set */
    #####: 1111:		    options.jump_port <= 0 ? "" : " -p ",
    #####: 1112:		    options.jump_port <= 0 ? "" : port_s,
        -: 1113:		    /* Optional additional jump hosts ",..." */
    #####: 1114:		    options.jump_extra == NULL ? "" : " -J ",
    #####: 1115:		    options.jump_extra == NULL ? "" : options.jump_extra,
        -: 1116:		    /* Optional "-F" argumment if -F specified */
    #####: 1117:		    config == NULL ? "" : " -F ",
    #####: 1118:		    config == NULL ? "" : config,
        -: 1119:		    /* Optional "-v" arguments if -v set */
    #####: 1120:		    debug_flag ? " -" : "",
        -: 1121:		    debug_flag, "vvv",
        -: 1122:		    /* Mandatory hostname */
        -: 1123:		    options.jump_host);
    #####: 1124:		debug("Setting implicit ProxyCommand from ProxyJump: %s",
        -: 1125:		    options.proxy_command);
        -: 1126:	}
        -: 1127:
        2: 1128:	if (options.port == 0)
        2: 1129:		options.port = default_ssh_port();
        2: 1130:	channel_set_af(options.address_family);
        -: 1131:
        -: 1132:	/* Tidy and check options */
        2: 1133:	if (options.host_key_alias != NULL)
    #####: 1134:		lowercase(options.host_key_alias);
        2: 1135:	if (options.proxy_command != NULL &&
    #####: 1136:	    strcmp(options.proxy_command, "-") == 0 &&
    #####: 1137:	    options.proxy_use_fdpass)
    #####: 1138:		fatal("ProxyCommand=- and ProxyUseFDPass are incompatible");
        2: 1139:	if (options.control_persist &&
    #####: 1140:	    options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {
    #####: 1141:		debug("UpdateHostKeys=ask is incompatible with ControlPersist; "
        -: 1142:		    "disabling");
    #####: 1143:		options.update_hostkeys = 0;
        -: 1144:	}
        2: 1145:	if (options.connection_attempts <= 0)
    #####: 1146:		fatal("Invalid number of ConnectionAttempts");
        -: 1147:#ifndef HAVE_CYGWIN
        2: 1148:	if (original_effective_uid != 0)
    #####: 1149:		options.use_privileged_port = 0;
        -: 1150:#endif
        -: 1151:
        -: 1152:	/* reinit */
        2: 1153:	log_init(argv0, options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
        -: 1154:
        4: 1155:	if (options.request_tty == REQUEST_TTY_YES ||
        2: 1156:	    options.request_tty == REQUEST_TTY_FORCE)
    #####: 1157:		tty_flag = 1;
        -: 1158:
        -: 1159:	/* Allocate a tty by default if no command specified. */
        2: 1160:	if (buffer_len(&command) == 0)
        2: 1161:		tty_flag = options.request_tty != REQUEST_TTY_NO;
        -: 1162:
        -: 1163:	/* Force no tty */
        4: 1164:	if (options.request_tty == REQUEST_TTY_NO ||
        2: 1165:	    (muxclient_command && muxclient_command != SSHMUX_COMMAND_PROXY))
    #####: 1166:		tty_flag = 0;
        -: 1167:	/* Do not allocate a tty if stdin is not a tty. */
        2: 1168:	if ((!isatty(fileno(stdin)) || stdin_null_flag) &&
    #####: 1169:	    options.request_tty != REQUEST_TTY_FORCE) {
    #####: 1170:		if (tty_flag)
    #####: 1171:			logit("Pseudo-terminal will not be allocated because "
        -: 1172:			    "stdin is not a terminal.");
    #####: 1173:		tty_flag = 0;
        -: 1174:	}
        -: 1175:
        2: 1176:	seed_rng();
        -: 1177:
        2: 1178:	if (options.user == NULL)
    #####: 1179:		options.user = xstrdup(pw->pw_name);
        -: 1180:
        2: 1181:	if (gethostname(thishost, sizeof(thishost)) == -1)
    #####: 1182:		fatal("gethostname: %s", strerror(errno));
        2: 1183:	strlcpy(shorthost, thishost, sizeof(shorthost));
        2: 1184:	shorthost[strcspn(thishost, ".")] = '\0';
        2: 1185:	snprintf(portstr, sizeof(portstr), "%d", options.port);
        2: 1186:	snprintf(uidstr, sizeof(uidstr), "%d", pw->pw_uid);
        -: 1187:
        4: 1188:	if ((md = ssh_digest_start(SSH_DIGEST_SHA1)) == NULL ||
        4: 1189:	    ssh_digest_update(md, thishost, strlen(thishost)) < 0 ||
        4: 1190:	    ssh_digest_update(md, host, strlen(host)) < 0 ||
        4: 1191:	    ssh_digest_update(md, portstr, strlen(portstr)) < 0 ||
        4: 1192:	    ssh_digest_update(md, options.user, strlen(options.user)) < 0 ||
        2: 1193:	    ssh_digest_final(md, conn_hash, sizeof(conn_hash)) < 0)
    #####: 1194:		fatal("%s: mux digest failed", __func__);
        2: 1195:	ssh_digest_free(md);
        2: 1196:	conn_hash_hex = tohex(conn_hash, ssh_digest_bytes(SSH_DIGEST_SHA1));
        -: 1197:
        2: 1198:	if (options.local_command != NULL) {
    #####: 1199:		debug3("expanding LocalCommand: %s", options.local_command);
    #####: 1200:		cp = options.local_command;
    #####: 1201:		options.local_command = percent_expand(cp,
        -: 1202:		    "C", conn_hash_hex,
        -: 1203:		    "L", shorthost,
        -: 1204:		    "d", pw->pw_dir,
        -: 1205:		    "h", host,
        -: 1206:		    "l", thishost,
        -: 1207:		    "n", host_arg,
        -: 1208:		    "p", portstr,
        -: 1209:		    "r", options.user,
        -: 1210:		    "u", pw->pw_name,
        -: 1211:		    (char *)NULL);
    #####: 1212:		debug3("expanded LocalCommand: %s", options.local_command);
    #####: 1213:		free(cp);
        -: 1214:	}
        -: 1215:
        2: 1216:	if (options.control_path != NULL) {
    #####: 1217:		cp = tilde_expand_filename(options.control_path,
        -: 1218:		    original_real_uid);
    #####: 1219:		free(options.control_path);
    #####: 1220:		options.control_path = percent_expand(cp,
        -: 1221:		    "C", conn_hash_hex,
        -: 1222:		    "L", shorthost,
        -: 1223:		    "h", host,
        -: 1224:		    "l", thishost,
        -: 1225:		    "n", host_arg,
        -: 1226:		    "p", portstr,
        -: 1227:		    "r", options.user,
        -: 1228:		    "u", pw->pw_name,
        -: 1229:		    "i", uidstr,
        -: 1230:		    (char *)NULL);
    #####: 1231:		free(cp);
        -: 1232:	}
        2: 1233:	free(conn_hash_hex);
        -: 1234:
        2: 1235:	if (config_test) {
    #####: 1236:		dump_client_config(&options, host);
    #####: 1237:		exit(0);
        -: 1238:	}
        -: 1239:
        2: 1240:	if (muxclient_command != 0 && options.control_path == NULL)
    #####: 1241:		fatal("No ControlPath specified for \"-O\" command");
        2: 1242:	if (options.control_path != NULL) {
        -: 1243:		int sock;
    #####: 1244:		if ((sock = muxclient(options.control_path)) >= 0) {
    #####: 1245:			packet_set_connection(sock, sock);
    #####: 1246:			ssh = active_state; /* XXX */
    #####: 1247:			enable_compat20();	/* XXX */
    #####: 1248:			packet_set_mux();
    #####: 1249:			goto skip_connect;
        -: 1250:		}
        -: 1251:	}
        -: 1252:
        -: 1253:	/*
        -: 1254:	 * If hostname canonicalisation was not enabled, then we may not
        -: 1255:	 * have yet resolved the hostname. Do so now.
        -: 1256:	 */
        2: 1257:	if (addrs == NULL && options.proxy_command == NULL) {
        2: 1258:		debug2("resolving \"%s\" port %d", host, options.port);
        2: 1259:		if ((addrs = resolve_host(host, options.port, 1,
        -: 1260:		    cname, sizeof(cname))) == NULL)
    #####: 1261:			cleanup_exit(255); /* resolve_host logs the error */
        -: 1262:	}
        -: 1263:
        2: 1264:	timeout_ms = options.connection_timeout * 1000;
        -: 1265:
        -: 1266:	/* Open a connection to the remote host. */
        2: 1267:	if (ssh_connect(host, addrs, &hostaddr, options.port,
        -: 1268:	    options.address_family, options.connection_attempts,
        -: 1269:	    &timeout_ms, options.tcp_keep_alive,
        -: 1270:	    options.use_privileged_port) != 0)
    #####: 1271: 		exit(255);
        -: 1272:
        2: 1273:	if (addrs != NULL)
        2: 1274:		freeaddrinfo(addrs);
        -: 1275:
        2: 1276:	packet_set_timeout(options.server_alive_interval,
        -: 1277:	    options.server_alive_count_max);
        -: 1278:
        2: 1279:	ssh = active_state; /* XXX */
        -: 1280:
        2: 1281:	if (timeout_ms > 0)
    #####: 1282:		debug3("timeout: %d ms remain after connect", timeout_ms);
        -: 1283:
        -: 1284:	/*
        -: 1285:	 * If we successfully made the connection, load the host private key
        -: 1286:	 * in case we will need it later for combined rsa-rhosts
        -: 1287:	 * authentication. This must be done before releasing extra
        -: 1288:	 * privileges, because the file is only readable by root.
        -: 1289:	 * If we cannot access the private keys, load the public keys
        -: 1290:	 * instead and try to execute the ssh-keysign helper instead.
        -: 1291:	 */
        2: 1292:	sensitive_data.nkeys = 0;
        2: 1293:	sensitive_data.keys = NULL;
        2: 1294:	sensitive_data.external_keysign = 0;
        4: 1295:	if (options.rhosts_rsa_authentication ||
        2: 1296:	    options.hostbased_authentication) {
    #####: 1297:		sensitive_data.nkeys = 9;
    #####: 1298:		sensitive_data.keys = xcalloc(sensitive_data.nkeys,
        -: 1299:		    sizeof(Key));
    #####: 1300:		for (i = 0; i < sensitive_data.nkeys; i++)
    #####: 1301:			sensitive_data.keys[i] = NULL;
        -: 1302:
    #####: 1303:		PRIV_START;
        -: 1304:#if WITH_SSH1
        -: 1305:		sensitive_data.keys[0] = key_load_private_type(KEY_RSA1,
        -: 1306:		    _PATH_HOST_KEY_FILE, "", NULL, NULL);
        -: 1307:#endif
        -: 1308:#ifdef OPENSSL_HAS_ECC
    #####: 1309:		sensitive_data.keys[1] = key_load_private_cert(KEY_ECDSA,
        -: 1310:		    _PATH_HOST_ECDSA_KEY_FILE, "", NULL);
        -: 1311:#endif
    #####: 1312:		sensitive_data.keys[2] = key_load_private_cert(KEY_ED25519,
        -: 1313:		    _PATH_HOST_ED25519_KEY_FILE, "", NULL);
    #####: 1314:		sensitive_data.keys[3] = key_load_private_cert(KEY_RSA,
        -: 1315:		    _PATH_HOST_RSA_KEY_FILE, "", NULL);
    #####: 1316:		sensitive_data.keys[4] = key_load_private_cert(KEY_DSA,
        -: 1317:		    _PATH_HOST_DSA_KEY_FILE, "", NULL);
        -: 1318:#ifdef OPENSSL_HAS_ECC
    #####: 1319:		sensitive_data.keys[5] = key_load_private_type(KEY_ECDSA,
        -: 1320:		    _PATH_HOST_ECDSA_KEY_FILE, "", NULL, NULL);
        -: 1321:#endif
    #####: 1322:		sensitive_data.keys[6] = key_load_private_type(KEY_ED25519,
        -: 1323:		    _PATH_HOST_ED25519_KEY_FILE, "", NULL, NULL);
    #####: 1324:		sensitive_data.keys[7] = key_load_private_type(KEY_RSA,
        -: 1325:		    _PATH_HOST_RSA_KEY_FILE, "", NULL, NULL);
    #####: 1326:		sensitive_data.keys[8] = key_load_private_type(KEY_DSA,
        -: 1327:		    _PATH_HOST_DSA_KEY_FILE, "", NULL, NULL);
    #####: 1328:		PRIV_END;
        -: 1329:
    #####: 1330:		if (options.hostbased_authentication == 1 &&
    #####: 1331:		    sensitive_data.keys[0] == NULL &&
    #####: 1332:		    sensitive_data.keys[5] == NULL &&
    #####: 1333:		    sensitive_data.keys[6] == NULL &&
    #####: 1334:		    sensitive_data.keys[7] == NULL &&
    #####: 1335:		    sensitive_data.keys[8] == NULL) {
        -: 1336:#ifdef OPENSSL_HAS_ECC
    #####: 1337:			sensitive_data.keys[1] = key_load_cert(
        -: 1338:			    _PATH_HOST_ECDSA_KEY_FILE);
        -: 1339:#endif
    #####: 1340:			sensitive_data.keys[2] = key_load_cert(
        -: 1341:			    _PATH_HOST_ED25519_KEY_FILE);
    #####: 1342:			sensitive_data.keys[3] = key_load_cert(
        -: 1343:			    _PATH_HOST_RSA_KEY_FILE);
    #####: 1344:			sensitive_data.keys[4] = key_load_cert(
        -: 1345:			    _PATH_HOST_DSA_KEY_FILE);
        -: 1346:#ifdef OPENSSL_HAS_ECC
    #####: 1347:			sensitive_data.keys[5] = key_load_public(
        -: 1348:			    _PATH_HOST_ECDSA_KEY_FILE, NULL);
        -: 1349:#endif
    #####: 1350:			sensitive_data.keys[6] = key_load_public(
        -: 1351:			    _PATH_HOST_ED25519_KEY_FILE, NULL);
    #####: 1352:			sensitive_data.keys[7] = key_load_public(
        -: 1353:			    _PATH_HOST_RSA_KEY_FILE, NULL);
    #####: 1354:			sensitive_data.keys[8] = key_load_public(
        -: 1355:			    _PATH_HOST_DSA_KEY_FILE, NULL);
    #####: 1356:			sensitive_data.external_keysign = 1;
        -: 1357:		}
        -: 1358:	}
        -: 1359:	/*
        -: 1360:	 * Get rid of any extra privileges that we may have.  We will no
        -: 1361:	 * longer need them.  Also, extra privileges could make it very hard
        -: 1362:	 * to read identity files and other non-world-readable files from the
        -: 1363:	 * user's home directory if it happens to be on a NFS volume where
        -: 1364:	 * root is mapped to nobody.
        -: 1365:	 */
        2: 1366:	if (original_effective_uid == 0) {
        2: 1367:		PRIV_START;
        2: 1368:		permanently_set_uid(pw);
        -: 1369:	}
        -: 1370:
        -: 1371:	/*
        -: 1372:	 * Now that we are back to our own permissions, create ~/.ssh
        -: 1373:	 * directory if it doesn't already exist.
        -: 1374:	 */
        2: 1375:	if (config == NULL) {
        2: 1376:		r = snprintf(buf, sizeof buf, "%s%s%s", pw->pw_dir,
        2: 1377:		    strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
        2: 1378:		if (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0) {
        -: 1379:#ifdef WITH_SELINUX
        -: 1380:			ssh_selinux_setfscreatecon(buf);
        -: 1381:#endif
    #####: 1382:			if (mkdir(buf, 0700) < 0)
    #####: 1383:				error("Could not create directory '%.200s'.",
        -: 1384:				    buf);
        -: 1385:#ifdef WITH_SELINUX
        -: 1386:			ssh_selinux_setfscreatecon(NULL);
        -: 1387:#endif
        -: 1388:		}
        -: 1389:	}
        -: 1390:	/* load options.identity_files */
        2: 1391:	load_public_identity_files();
        -: 1392:
        -: 1393:	/* optionally set the SSH_AUTHSOCKET_ENV_NAME varibale */
        2: 1394:	if (options.identity_agent &&
    #####: 1395:	    strcmp(options.identity_agent, SSH_AUTHSOCKET_ENV_NAME) != 0) {
    #####: 1396:		if (strcmp(options.identity_agent, "none") == 0) {
    #####: 1397:			unsetenv(SSH_AUTHSOCKET_ENV_NAME);
        -: 1398:		} else {
    #####: 1399:			p = tilde_expand_filename(options.identity_agent,
        -: 1400:			    original_real_uid);
    #####: 1401:			cp = percent_expand(p, "d", pw->pw_dir,
        -: 1402:			    "u", pw->pw_name, "l", thishost, "h", host,
        -: 1403:			    "r", options.user, (char *)NULL);
    #####: 1404:			setenv(SSH_AUTHSOCKET_ENV_NAME, cp, 1);
    #####: 1405:			free(cp);
    #####: 1406:			free(p);
        -: 1407:		}
        -: 1408:	}
        -: 1409:
        -: 1410:	/* Expand ~ in known host file names. */
        2: 1411:	tilde_expand_paths(options.system_hostfiles,
        -: 1412:	    options.num_system_hostfiles);
        2: 1413:	tilde_expand_paths(options.user_hostfiles, options.num_user_hostfiles);
        -: 1414:
        2: 1415:	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */
        2: 1416:	signal(SIGCHLD, main_sigchld_handler);
        -: 1417:
        -: 1418:	/* Log into the remote system.  Never returns if the login fails. */
        4: 1419:	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr,
        2: 1420:	    options.port, pw, timeout_ms);
        -: 1421:
        2: 1422:	if (packet_connection_is_on_socket()) {
        2: 1423:		verbose("Authenticated to %s ([%s]:%d).", host,
        -: 1424:		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
        -: 1425:	} else {
    #####: 1426:		verbose("Authenticated to %s (via proxy).", host);
        -: 1427:	}
        -: 1428:
        -: 1429:	/* We no longer need the private host keys.  Clear them now. */
        2: 1430:	if (sensitive_data.nkeys != 0) {
    #####: 1431:		for (i = 0; i < sensitive_data.nkeys; i++) {
    #####: 1432:			if (sensitive_data.keys[i] != NULL) {
        -: 1433:				/* Destroys contents safely */
    #####: 1434:				debug3("clear hostkey %d", i);
    #####: 1435:				key_free(sensitive_data.keys[i]);
    #####: 1436:				sensitive_data.keys[i] = NULL;
        -: 1437:			}
        -: 1438:		}
    #####: 1439:		free(sensitive_data.keys);
        -: 1440:	}
       10: 1441:	for (i = 0; i < options.num_identity_files; i++) {
        8: 1442:		free(options.identity_files[i]);
        8: 1443:		options.identity_files[i] = NULL;
        8: 1444:		if (options.identity_keys[i]) {
    #####: 1445:			key_free(options.identity_keys[i]);
    #####: 1446:			options.identity_keys[i] = NULL;
        -: 1447:		}
        -: 1448:	}
        2: 1449:	for (i = 0; i < options.num_certificate_files; i++) {
    #####: 1450:		free(options.certificate_files[i]);
    #####: 1451:		options.certificate_files[i] = NULL;
        -: 1452:	}
        -: 1453:
        -: 1454: skip_connect:
        2: 1455:	exit_status = compat20 ? ssh_session2() : ssh_session();
        2: 1456:	packet_close();
        -: 1457:
        2: 1458:	if (options.control_path != NULL && muxserver_sock != -1)
    #####: 1459:		unlink(options.control_path);
        -: 1460:
        -: 1461:	/* Kill ProxyCommand if it is running. */
        2: 1462:	ssh_kill_proxy_command();
        -: 1463:
        2: 1464:	return exit_status;
        -: 1465:}
        -: 1466:
        -: 1467:static void
    #####: 1468:control_persist_detach(void)
        -: 1469:{
        -: 1470:	pid_t pid;
        -: 1471:	int devnull, keep_stderr;
        -: 1472:
    #####: 1473:	debug("%s: backgrounding master process", __func__);
        -: 1474:
        -: 1475: 	/*
        -: 1476: 	 * master (current process) into the background, and make the
        -: 1477: 	 * foreground process a client of the backgrounded master.
        -: 1478: 	 */
    #####: 1479:	switch ((pid = fork())) {
        -: 1480:	case -1:
    #####: 1481:		fatal("%s: fork: %s", __func__, strerror(errno));
        -: 1482:	case 0:
        -: 1483:		/* Child: master process continues mainloop */
    #####: 1484: 		break;
        -: 1485: 	default:
        -: 1486:		/* Parent: set up mux slave to connect to backgrounded master */
    #####: 1487:		debug2("%s: background process is %ld", __func__, (long)pid);
    #####: 1488:		stdin_null_flag = ostdin_null_flag;
    #####: 1489:		options.request_tty = orequest_tty;
    #####: 1490:		tty_flag = otty_flag;
    #####: 1491: 		close(muxserver_sock);
    #####: 1492: 		muxserver_sock = -1;
    #####: 1493:		options.control_master = SSHCTL_MASTER_NO;
    #####: 1494: 		muxclient(options.control_path);
        -: 1495:		/* muxclient() doesn't return on success. */
    #####: 1496: 		fatal("Failed to connect to new control master");
        -: 1497: 	}
    #####: 1498:	if ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {
    #####: 1499:		error("%s: open(\"/dev/null\"): %s", __func__,
    #####: 1500:		    strerror(errno));
        -: 1501:	} else {
    #####: 1502:		keep_stderr = log_is_on_stderr() && debug_flag;
    #####: 1503:		if (dup2(devnull, STDIN_FILENO) == -1 ||
    #####: 1504:		    dup2(devnull, STDOUT_FILENO) == -1 ||
    #####: 1505:		    (!keep_stderr && dup2(devnull, STDERR_FILENO) == -1))
    #####: 1506:			error("%s: dup2: %s", __func__, strerror(errno));
    #####: 1507:		if (devnull > STDERR_FILENO)
    #####: 1508:			close(devnull);
        -: 1509:	}
    #####: 1510:	daemon(1, 1);
    #####: 1511:	setproctitle("%s [mux]", options.control_path);
    #####: 1512:}
        -: 1513:
        -: 1514:/* Do fork() after authentication. Used by "ssh -f" */
        -: 1515:static void
    #####: 1516:fork_postauth(void)
        -: 1517:{
    #####: 1518:	if (need_controlpersist_detach)
    #####: 1519:		control_persist_detach();
    #####: 1520:	debug("forking to background");
    #####: 1521:	fork_after_authentication_flag = 0;
    #####: 1522:	if (daemon(1, 1) < 0)
    #####: 1523:		fatal("daemon() failed: %.200s", strerror(errno));
    #####: 1524:}
        -: 1525:
        -: 1526:/* Callback for remote forward global requests */
        -: 1527:static void
    #####: 1528:ssh_confirm_remote_forward(int type, u_int32_t seq, void *ctxt)
        -: 1529:{
    #####: 1530:	struct Forward *rfwd = (struct Forward *)ctxt;
        -: 1531:
        -: 1532:	/* XXX verbose() on failure? */
    #####: 1533:	debug("remote forward %s for: listen %s%s%d, connect %s:%d",
        -: 1534:	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
    #####: 1535:	    rfwd->listen_path ? rfwd->listen_path :
    #####: 1536:	    rfwd->listen_host ? rfwd->listen_host : "",
    #####: 1537:	    (rfwd->listen_path || rfwd->listen_host) ? ":" : "",
    #####: 1538:	    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :
        -: 1539:	    rfwd->connect_host, rfwd->connect_port);
    #####: 1540:	if (rfwd->listen_path == NULL && rfwd->listen_port == 0) {
    #####: 1541:		if (type == SSH2_MSG_REQUEST_SUCCESS) {
    #####: 1542:			rfwd->allocated_port = packet_get_int();
    #####: 1543:			logit("Allocated port %u for remote forward to %s:%d",
        -: 1544:			    rfwd->allocated_port,
        -: 1545:			    rfwd->connect_host, rfwd->connect_port);
    #####: 1546:			channel_update_permitted_opens(rfwd->handle,
        -: 1547:			    rfwd->allocated_port);
        -: 1548:		} else {
    #####: 1549:			channel_update_permitted_opens(rfwd->handle, -1);
        -: 1550:		}
        -: 1551:	}
        -: 1552:	
    #####: 1553:	if (type == SSH2_MSG_REQUEST_FAILURE) {
    #####: 1554:		if (options.exit_on_forward_failure) {
    #####: 1555:			if (rfwd->listen_path != NULL)
    #####: 1556:				fatal("Error: remote port forwarding failed "
        -: 1557:				    "for listen path %s", rfwd->listen_path);
        -: 1558:			else
    #####: 1559:				fatal("Error: remote port forwarding failed "
        -: 1560:				    "for listen port %d", rfwd->listen_port);
        -: 1561:		} else {
    #####: 1562:			if (rfwd->listen_path != NULL)
    #####: 1563:				logit("Warning: remote port forwarding failed "
        -: 1564:				    "for listen path %s", rfwd->listen_path);
        -: 1565:			else
    #####: 1566:				logit("Warning: remote port forwarding failed "
        -: 1567:				    "for listen port %d", rfwd->listen_port);
        -: 1568:		}
        -: 1569:	}
    #####: 1570:	if (++remote_forward_confirms_received == options.num_remote_forwards) {
    #####: 1571:		debug("All remote forwarding requests processed");
    #####: 1572:		if (fork_after_authentication_flag)
    #####: 1573:			fork_postauth();
        -: 1574:	}
    #####: 1575:}
        -: 1576:
        -: 1577:static void
    #####: 1578:client_cleanup_stdio_fwd(int id, void *arg)
        -: 1579:{
    #####: 1580:	debug("stdio forwarding: done");
    #####: 1581:	cleanup_exit(0);
        -: 1582:}
        -: 1583:
        -: 1584:static void
    #####: 1585:ssh_stdio_confirm(int id, int success, void *arg)
        -: 1586:{
    #####: 1587:	if (!success)
    #####: 1588:		fatal("stdio forwarding failed");
    #####: 1589:}
        -: 1590:
        -: 1591:static void
        2: 1592:ssh_init_stdio_forwarding(void)
        -: 1593:{
        -: 1594:	Channel *c;
        -: 1595:	int in, out;
        -: 1596:
        2: 1597:	if (options.stdio_forward_host == NULL)
        4: 1598:		return;
    #####: 1599:	if (!compat20)
    #####: 1600:		fatal("stdio forwarding require Protocol 2");
        -: 1601:
    #####: 1602:	debug3("%s: %s:%d", __func__, options.stdio_forward_host,
        -: 1603:	    options.stdio_forward_port);
        -: 1604:
    #####: 1605:	if ((in = dup(STDIN_FILENO)) < 0 ||
        -: 1606:	    (out = dup(STDOUT_FILENO)) < 0)
    #####: 1607:		fatal("channel_connect_stdio_fwd: dup() in/out failed");
    #####: 1608:	if ((c = channel_connect_stdio_fwd(options.stdio_forward_host,
    #####: 1609:	    options.stdio_forward_port, in, out)) == NULL)
    #####: 1610:		fatal("%s: channel_connect_stdio_fwd failed", __func__);
    #####: 1611:	channel_register_cleanup(c->self, client_cleanup_stdio_fwd, 0);
    #####: 1612:	channel_register_open_confirm(c->self, ssh_stdio_confirm, NULL);
        -: 1613:}
        -: 1614:
        -: 1615:static void
        2: 1616:ssh_init_forwarding(void)
        -: 1617:{
        2: 1618:	int success = 0;
        -: 1619:	int i;
        -: 1620:
        -: 1621:	/* Initiate local TCP/IP port forwardings. */
        2: 1622:	for (i = 0; i < options.num_local_forwards; i++) {
    #####: 1623:		debug("Local connections to %.200s:%d forwarded to remote "
        -: 1624:		    "address %.200s:%d",
    #####: 1625:		    (options.local_forwards[i].listen_path != NULL) ?
    #####: 1626:		    options.local_forwards[i].listen_path :
    #####: 1627:		    (options.local_forwards[i].listen_host == NULL) ?
    #####: 1628:		    (options.fwd_opts.gateway_ports ? "*" : "LOCALHOST") :
    #####: 1629:		    options.local_forwards[i].listen_host,
    #####: 1630:		    options.local_forwards[i].listen_port,
    #####: 1631:		    (options.local_forwards[i].connect_path != NULL) ?
    #####: 1632:		    options.local_forwards[i].connect_path :
    #####: 1633:		    options.local_forwards[i].connect_host,
    #####: 1634:		    options.local_forwards[i].connect_port);
    #####: 1635:		success += channel_setup_local_fwd_listener(
    #####: 1636:		    &options.local_forwards[i], &options.fwd_opts);
        -: 1637:	}
        2: 1638:	if (i > 0 && success != i && options.exit_on_forward_failure)
    #####: 1639:		fatal("Could not request local forwarding.");
        2: 1640:	if (i > 0 && success == 0)
    #####: 1641:		error("Could not request local forwarding.");
        -: 1642:
        -: 1643:	/* Initiate remote TCP/IP port forwardings. */
        2: 1644:	for (i = 0; i < options.num_remote_forwards; i++) {
    #####: 1645:		debug("Remote connections from %.200s:%d forwarded to "
        -: 1646:		    "local address %.200s:%d",
    #####: 1647:		    (options.remote_forwards[i].listen_path != NULL) ?
    #####: 1648:		    options.remote_forwards[i].listen_path :
    #####: 1649:		    (options.remote_forwards[i].listen_host == NULL) ?
    #####: 1650:		    "LOCALHOST" : options.remote_forwards[i].listen_host,
    #####: 1651:		    options.remote_forwards[i].listen_port,
    #####: 1652:		    (options.remote_forwards[i].connect_path != NULL) ?
    #####: 1653:		    options.remote_forwards[i].connect_path :
    #####: 1654:		    options.remote_forwards[i].connect_host,
    #####: 1655:		    options.remote_forwards[i].connect_port);
    #####: 1656:		options.remote_forwards[i].handle =
    #####: 1657:		    channel_request_remote_forwarding(
    #####: 1658:		    &options.remote_forwards[i]);
    #####: 1659:		if (options.remote_forwards[i].handle < 0) {
    #####: 1660:			if (options.exit_on_forward_failure)
    #####: 1661:				fatal("Could not request remote forwarding.");
        -: 1662:			else
    #####: 1663:				logit("Warning: Could not request remote "
        -: 1664:				    "forwarding.");
        -: 1665:		} else {
    #####: 1666:			client_register_global_confirm(ssh_confirm_remote_forward,
    #####: 1667:			    &options.remote_forwards[i]);
        -: 1668:		}
        -: 1669:	}
        -: 1670:
        -: 1671:	/* Initiate tunnel forwarding. */
        2: 1672:	if (options.tun_open != SSH_TUNMODE_NO) {
    #####: 1673:		if (client_request_tun_fwd(options.tun_open,
        -: 1674:		    options.tun_local, options.tun_remote) == -1) {
    #####: 1675:			if (options.exit_on_forward_failure)
    #####: 1676:				fatal("Could not request tunnel forwarding.");
        -: 1677:			else
    #####: 1678:				error("Could not request tunnel forwarding.");
        -: 1679:		}
        -: 1680:	}			
        2: 1681:}
        -: 1682:
        -: 1683:static void
        2: 1684:check_agent_present(void)
        -: 1685:{
        -: 1686:	int r;
        -: 1687:
        2: 1688:	if (options.forward_agent) {
        -: 1689:		/* Clear agent forwarding if we don't have an agent. */
    #####: 1690:		if ((r = ssh_get_authentication_socket(NULL)) != 0) {
    #####: 1691:			options.forward_agent = 0;
    #####: 1692:			if (r != SSH_ERR_AGENT_NOT_PRESENT)
    #####: 1693:				debug("ssh_get_authentication_socket: %s",
        -: 1694:				    ssh_err(r));
        -: 1695:		}
        -: 1696:	}
        2: 1697:}
        -: 1698:
        -: 1699:static int
    #####: 1700:ssh_session(void)
        -: 1701:{
        -: 1702:	int type;
    #####: 1703:	int interactive = 0;
    #####: 1704:	int have_tty = 0;
        -: 1705:	struct winsize ws;
        -: 1706:	char *cp;
        -: 1707:	const char *display;
    #####: 1708:	char *proto = NULL, *data = NULL;
        -: 1709:
        -: 1710:	/* Enable compression if requested. */
    #####: 1711:	if (options.compression) {
    #####: 1712:		debug("Requesting compression at level %d.",
        -: 1713:		    options.compression_level);
        -: 1714:
    #####: 1715:		if (options.compression_level < 1 ||
    #####: 1716:		    options.compression_level > 9)
    #####: 1717:			fatal("Compression level must be from 1 (fast) to "
        -: 1718:			    "9 (slow, best).");
        -: 1719:
        -: 1720:		/* Send the request. */
    #####: 1721:		packet_start(SSH_CMSG_REQUEST_COMPRESSION);
    #####: 1722:		packet_put_int(options.compression_level);
    #####: 1723:		packet_send();
    #####: 1724:		packet_write_wait();
    #####: 1725:		type = packet_read();
    #####: 1726:		if (type == SSH_SMSG_SUCCESS)
    #####: 1727:			packet_start_compression(options.compression_level);
    #####: 1728:		else if (type == SSH_SMSG_FAILURE)
    #####: 1729:			logit("Warning: Remote host refused compression.");
        -: 1730:		else
    #####: 1731:			packet_disconnect("Protocol error waiting for "
        -: 1732:			    "compression response.");
        -: 1733:	}
        -: 1734:	/* Allocate a pseudo tty if appropriate. */
    #####: 1735:	if (tty_flag) {
    #####: 1736:		debug("Requesting pty.");
        -: 1737:
        -: 1738:		/* Start the packet. */
    #####: 1739:		packet_start(SSH_CMSG_REQUEST_PTY);
        -: 1740:
        -: 1741:		/* Store TERM in the packet.  There is no limit on the
        -: 1742:		   length of the string. */
    #####: 1743:		cp = getenv("TERM");
    #####: 1744:		if (!cp)
    #####: 1745:			cp = "";
    #####: 1746:		packet_put_cstring(cp);
        -: 1747:
        -: 1748:		/* Store window size in the packet. */
    #####: 1749:		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
    #####: 1750:			memset(&ws, 0, sizeof(ws));
    #####: 1751:		packet_put_int((u_int)ws.ws_row);
    #####: 1752:		packet_put_int((u_int)ws.ws_col);
    #####: 1753:		packet_put_int((u_int)ws.ws_xpixel);
    #####: 1754:		packet_put_int((u_int)ws.ws_ypixel);
        -: 1755:
        -: 1756:		/* Store tty modes in the packet. */
    #####: 1757:		tty_make_modes(fileno(stdin), NULL);
        -: 1758:
        -: 1759:		/* Send the packet, and wait for it to leave. */
    #####: 1760:		packet_send();
    #####: 1761:		packet_write_wait();
        -: 1762:
        -: 1763:		/* Read response from the server. */
    #####: 1764:		type = packet_read();
    #####: 1765:		if (type == SSH_SMSG_SUCCESS) {
    #####: 1766:			interactive = 1;
    #####: 1767:			have_tty = 1;
    #####: 1768:		} else if (type == SSH_SMSG_FAILURE)
    #####: 1769:			logit("Warning: Remote host failed or refused to "
        -: 1770:			    "allocate a pseudo tty.");
        -: 1771:		else
    #####: 1772:			packet_disconnect("Protocol error waiting for pty "
        -: 1773:			    "request response.");
        -: 1774:	}
        -: 1775:	/* Request X11 forwarding if enabled and DISPLAY is set. */
    #####: 1776:	display = getenv("DISPLAY");
    #####: 1777:	if (display == NULL && options.forward_x11)
    #####: 1778:		debug("X11 forwarding requested but DISPLAY not set");
    #####: 1779:	if (options.forward_x11 && client_x11_get_proto(display,
    #####: 1780:	    options.xauth_location, options.forward_x11_trusted,
    #####: 1781:	    options.forward_x11_timeout, &proto, &data) == 0) {
        -: 1782:		/* Request forwarding with authentication spoofing. */
    #####: 1783:		debug("Requesting X11 forwarding with authentication "
        -: 1784:		    "spoofing.");
    #####: 1785:		x11_request_forwarding_with_spoofing(0, display, proto,
        -: 1786:		    data, 0);
        -: 1787:		/* Read response from the server. */
    #####: 1788:		type = packet_read();
    #####: 1789:		if (type == SSH_SMSG_SUCCESS) {
    #####: 1790:			interactive = 1;
    #####: 1791:		} else if (type == SSH_SMSG_FAILURE) {
    #####: 1792:			logit("Warning: Remote host denied X11 forwarding.");
        -: 1793:		} else {
    #####: 1794:			packet_disconnect("Protocol error waiting for X11 "
        -: 1795:			    "forwarding");
        -: 1796:		}
        -: 1797:	}
        -: 1798:	/* Tell the packet module whether this is an interactive session. */
    #####: 1799:	packet_set_interactive(interactive,
        -: 1800:	    options.ip_qos_interactive, options.ip_qos_bulk);
        -: 1801:
        -: 1802:	/* Request authentication agent forwarding if appropriate. */
    #####: 1803:	check_agent_present();
        -: 1804:
    #####: 1805:	if (options.forward_agent) {
    #####: 1806:		debug("Requesting authentication agent forwarding.");
    #####: 1807:		auth_request_forwarding();
        -: 1808:
        -: 1809:		/* Read response from the server. */
    #####: 1810:		type = packet_read();
    #####: 1811:		packet_check_eom();
    #####: 1812:		if (type != SSH_SMSG_SUCCESS)
    #####: 1813:			logit("Warning: Remote host denied authentication agent forwarding.");
        -: 1814:	}
        -: 1815:
        -: 1816:	/* Initiate port forwardings. */
    #####: 1817:	ssh_init_stdio_forwarding();
    #####: 1818:	ssh_init_forwarding();
        -: 1819:
        -: 1820:	/* Execute a local command */
    #####: 1821:	if (options.local_command != NULL &&
    #####: 1822:	    options.permit_local_command)
    #####: 1823:		ssh_local_cmd(options.local_command);
        -: 1824:
        -: 1825:	/*
        -: 1826:	 * If requested and we are not interested in replies to remote
        -: 1827:	 * forwarding requests, then let ssh continue in the background.
        -: 1828:	 */
    #####: 1829:	if (fork_after_authentication_flag) {
    #####: 1830:		if (options.exit_on_forward_failure &&
    #####: 1831:		    options.num_remote_forwards > 0) {
    #####: 1832:			debug("deferring postauth fork until remote forward "
        -: 1833:			    "confirmation received");
        -: 1834:		} else
    #####: 1835:			fork_postauth();
        -: 1836:	}
        -: 1837:
        -: 1838:	/*
        -: 1839:	 * If a command was specified on the command line, execute the
        -: 1840:	 * command now. Otherwise request the server to start a shell.
        -: 1841:	 */
    #####: 1842:	if (buffer_len(&command) > 0) {
    #####: 1843:		int len = buffer_len(&command);
    #####: 1844:		if (len > 900)
    #####: 1845:			len = 900;
    #####: 1846:		debug("Sending command: %.*s", len,
        -: 1847:		    (u_char *)buffer_ptr(&command));
    #####: 1848:		packet_start(SSH_CMSG_EXEC_CMD);
    #####: 1849:		packet_put_string(buffer_ptr(&command), buffer_len(&command));
    #####: 1850:		packet_send();
    #####: 1851:		packet_write_wait();
        -: 1852:	} else {
    #####: 1853:		debug("Requesting shell.");
    #####: 1854:		packet_start(SSH_CMSG_EXEC_SHELL);
    #####: 1855:		packet_send();
    #####: 1856:		packet_write_wait();
        -: 1857:	}
        -: 1858:
        -: 1859:	/* Enter the interactive session. */
    #####: 1860:	return client_loop(have_tty, tty_flag ?
        -: 1861:	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
        -: 1862:}
        -: 1863:
        -: 1864:/* request pty/x11/agent/tcpfwd/shell for channel */
        -: 1865:static void
        2: 1866:ssh_session2_setup(int id, int success, void *arg)
        -: 1867:{
        -: 1868:	extern char **environ;
        -: 1869:	const char *display;
        2: 1870:	int interactive = tty_flag;
        2: 1871:	char *proto = NULL, *data = NULL;
        -: 1872:
        2: 1873:	if (!success)
        2: 1874:		return; /* No need for error message, channels code sens one */
        -: 1875:
        2: 1876:	display = getenv("DISPLAY");
        2: 1877:	if (display == NULL && options.forward_x11)
    #####: 1878:		debug("X11 forwarding requested but DISPLAY not set");
        2: 1879:	if (options.forward_x11 && client_x11_get_proto(display,
    #####: 1880:	    options.xauth_location, options.forward_x11_trusted,
    #####: 1881:	    options.forward_x11_timeout, &proto, &data) == 0) {
        -: 1882:		/* Request forwarding with authentication spoofing. */
    #####: 1883:		debug("Requesting X11 forwarding with authentication "
        -: 1884:		    "spoofing.");
    #####: 1885:		x11_request_forwarding_with_spoofing(id, display, proto,
        -: 1886:		    data, 1);
    #####: 1887:		client_expect_confirm(id, "X11 forwarding", CONFIRM_WARN);
        -: 1888:		/* XXX exit_on_forward_failure */
    #####: 1889:		interactive = 1;
        -: 1890:	}
        -: 1891:
        2: 1892:	check_agent_present();
        2: 1893:	if (options.forward_agent) {
    #####: 1894:		debug("Requesting authentication agent forwarding.");
    #####: 1895:		channel_request_start(id, "auth-agent-req@openssh.com", 0);
    #####: 1896:		packet_send();
        -: 1897:	}
        -: 1898:
        -: 1899:	/* Tell the packet module whether this is an interactive session. */
        2: 1900:	packet_set_interactive(interactive,
        -: 1901:	    options.ip_qos_interactive, options.ip_qos_bulk);
        -: 1902:
        2: 1903:	client_session2_setup(id, tty_flag, subsystem_flag, getenv("TERM"),
        -: 1904:	    NULL, fileno(stdin), &command, environ);
        -: 1905:}
        -: 1906:
        -: 1907:/* open new channel for a session */
        -: 1908:static int
        2: 1909:ssh_session2_open(void)
        -: 1910:{
        -: 1911:	Channel *c;
        -: 1912:	int window, packetmax, in, out, err;
        -: 1913:
        2: 1914:	if (stdin_null_flag) {
    #####: 1915:		in = open(_PATH_DEVNULL, O_RDONLY);
        -: 1916:	} else {
        2: 1917:		in = dup(STDIN_FILENO);
        -: 1918:	}
        2: 1919:	out = dup(STDOUT_FILENO);
        2: 1920:	err = dup(STDERR_FILENO);
        -: 1921:
        2: 1922:	if (in < 0 || out < 0 || err < 0)
    #####: 1923:		fatal("dup() in/out/err failed");
        -: 1924:
        -: 1925:	/* enable nonblocking unless tty */
        2: 1926:	if (!isatty(in))
    #####: 1927:		set_nonblock(in);
        2: 1928:	if (!isatty(out))
    #####: 1929:		set_nonblock(out);
        2: 1930:	if (!isatty(err))
    #####: 1931:		set_nonblock(err);
        -: 1932:
        2: 1933:	window = CHAN_SES_WINDOW_DEFAULT;
        2: 1934:	packetmax = CHAN_SES_PACKET_DEFAULT;
        2: 1935:	if (tty_flag) {
        2: 1936:		window >>= 1;
        2: 1937:		packetmax >>= 1;
        -: 1938:	}
        2: 1939:	c = channel_new(
        -: 1940:	    "session", SSH_CHANNEL_OPENING, in, out, err,
        -: 1941:	    window, packetmax, CHAN_EXTENDED_WRITE,
        -: 1942:	    "client-session", /*nonblock*/0);
        -: 1943:
        2: 1944:	debug3("ssh_session2_open: channel_new: %d", c->self);
        -: 1945:
        2: 1946:	channel_send_open(c->self);
        2: 1947:	if (!no_shell_flag)
        2: 1948:		channel_register_open_confirm(c->self,
        -: 1949:		    ssh_session2_setup, NULL);
        -: 1950:
        2: 1951:	return c->self;
        -: 1952:}
        -: 1953:
        -: 1954:static int
        2: 1955:ssh_session2(void)
        -: 1956:{
        2: 1957:	int id = -1;
        -: 1958:
        -: 1959:	/* XXX should be pre-session */
        2: 1960:	if (!options.control_persist)
        2: 1961:		ssh_init_stdio_forwarding();
        2: 1962:	ssh_init_forwarding();
        -: 1963:
        -: 1964:	/* Start listening for multiplex clients */
        2: 1965:	if (!packet_get_mux())
        2: 1966:		muxserver_listen();
        -: 1967:
        -: 1968: 	/*
        -: 1969:	 * If we are in control persist mode and have a working mux listen
        -: 1970:	 * socket, then prepare to background ourselves and have a foreground
        -: 1971:	 * client attach as a control slave.
        -: 1972:	 * NB. we must save copies of the flags that we override for
        -: 1973:	 * the backgrounding, since we defer attachment of the slave until
        -: 1974:	 * after the connection is fully established (in particular,
        -: 1975:	 * async rfwd replies have been received for ExitOnForwardFailure).
        -: 1976:	 */
        2: 1977: 	if (options.control_persist && muxserver_sock != -1) {
    #####: 1978:		ostdin_null_flag = stdin_null_flag;
    #####: 1979:		ono_shell_flag = no_shell_flag;
    #####: 1980:		orequest_tty = options.request_tty;
    #####: 1981:		otty_flag = tty_flag;
    #####: 1982: 		stdin_null_flag = 1;
    #####: 1983: 		no_shell_flag = 1;
    #####: 1984: 		tty_flag = 0;
    #####: 1985:		if (!fork_after_authentication_flag)
    #####: 1986:			need_controlpersist_detach = 1;
    #####: 1987:		fork_after_authentication_flag = 1;
        -: 1988: 	}
        -: 1989:	/*
        -: 1990:	 * ControlPersist mux listen socket setup failed, attempt the
        -: 1991:	 * stdio forward setup that we skipped earlier.
        -: 1992:	 */
        2: 1993:	if (options.control_persist && muxserver_sock == -1)
    #####: 1994:		ssh_init_stdio_forwarding();
        -: 1995:
        2: 1996:	if (!no_shell_flag || (datafellows & SSH_BUG_DUMMYCHAN))
        2: 1997:		id = ssh_session2_open();
        -: 1998:	else {
    #####: 1999:		packet_set_interactive(
        -: 2000:		    options.control_master == SSHCTL_MASTER_NO,
        -: 2001:		    options.ip_qos_interactive, options.ip_qos_bulk);
        -: 2002:	}
        -: 2003:
        -: 2004:	/* If we don't expect to open a new session, then disallow it */
        4: 2005:	if (options.control_master == SSHCTL_MASTER_NO &&
        2: 2006:	    (datafellows & SSH_NEW_OPENSSH)) {
        2: 2007:		debug("Requesting no-more-sessions@openssh.com");
        2: 2008:		packet_start(SSH2_MSG_GLOBAL_REQUEST);
        2: 2009:		packet_put_cstring("no-more-sessions@openssh.com");
        2: 2010:		packet_put_char(0);
        2: 2011:		packet_send();
        -: 2012:	}
        -: 2013:
        -: 2014:	/* Execute a local command */
        2: 2015:	if (options.local_command != NULL &&
    #####: 2016:	    options.permit_local_command)
    #####: 2017:		ssh_local_cmd(options.local_command);
        -: 2018:
        -: 2019:	/*
        -: 2020:	 * If requested and we are not interested in replies to remote
        -: 2021:	 * forwarding requests, then let ssh continue in the background.
        -: 2022:	 */
        2: 2023:	if (fork_after_authentication_flag) {
    #####: 2024:		if (options.exit_on_forward_failure &&
    #####: 2025:		    options.num_remote_forwards > 0) {
    #####: 2026:			debug("deferring postauth fork until remote forward "
        -: 2027:			    "confirmation received");
        -: 2028:		} else
    #####: 2029:			fork_postauth();
        -: 2030:	}
        -: 2031:
        2: 2032:	return client_loop(tty_flag, tty_flag ?
        -: 2033:	    options.escape_char : SSH_ESCAPECHAR_NONE, id);
        -: 2034:}
        -: 2035:
        -: 2036:/* Loads all IdentityFile and CertificateFile keys */
        -: 2037:static void
        2: 2038:load_public_identity_files(void)
        -: 2039:{
        -: 2040:	char *filename, *cp, thishost[NI_MAXHOST];
        2: 2041:	char *pwdir = NULL, *pwname = NULL;
        -: 2042:	Key *public;
        -: 2043:	struct passwd *pw;
        -: 2044:	int i;
        -: 2045:	u_int n_ids, n_certs;
        -: 2046:	char *identity_files[SSH_MAX_IDENTITY_FILES];
        -: 2047:	Key *identity_keys[SSH_MAX_IDENTITY_FILES];
        -: 2048:	char *certificate_files[SSH_MAX_CERTIFICATE_FILES];
        -: 2049:	struct sshkey *certificates[SSH_MAX_CERTIFICATE_FILES];
        -: 2050:#ifdef ENABLE_PKCS11
        -: 2051:	Key **keys;
        -: 2052:	int nkeys;
        -: 2053:#endif /* PKCS11 */
        -: 2054:
        2: 2055:	n_ids = n_certs = 0;
        2: 2056:	memset(identity_files, 0, sizeof(identity_files));
        2: 2057:	memset(identity_keys, 0, sizeof(identity_keys));
        2: 2058:	memset(certificate_files, 0, sizeof(certificate_files));
        2: 2059:	memset(certificates, 0, sizeof(certificates));
        -: 2060:
        -: 2061:#ifdef ENABLE_PKCS11
        2: 2062:	if (options.pkcs11_provider != NULL &&
    #####: 2063:	    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&
    #####: 2064:	    (pkcs11_init(!options.batch_mode) == 0) &&
    #####: 2065:	    (nkeys = pkcs11_add_provider(options.pkcs11_provider, NULL,
        -: 2066:	    &keys)) > 0) {
    #####: 2067:		for (i = 0; i < nkeys; i++) {
    #####: 2068:			if (n_ids >= SSH_MAX_IDENTITY_FILES) {
    #####: 2069:				key_free(keys[i]);
    #####: 2070:				continue;
        -: 2071:			}
    #####: 2072:			identity_keys[n_ids] = keys[i];
    #####: 2073:			identity_files[n_ids] =
    #####: 2074:			    xstrdup(options.pkcs11_provider); /* XXX */
    #####: 2075:			n_ids++;
        -: 2076:		}
    #####: 2077:		free(keys);
        -: 2078:	}
        -: 2079:#endif /* ENABLE_PKCS11 */
        2: 2080:	if ((pw = getpwuid(original_real_uid)) == NULL)
    #####: 2081:		fatal("load_public_identity_files: getpwuid failed");
        2: 2082:	pwname = xstrdup(pw->pw_name);
        2: 2083:	pwdir = xstrdup(pw->pw_dir);
        2: 2084:	if (gethostname(thishost, sizeof(thishost)) == -1)
    #####: 2085:		fatal("load_public_identity_files: gethostname: %s",
    #####: 2086:		    strerror(errno));
       10: 2087:	for (i = 0; i < options.num_identity_files; i++) {
       16: 2088:		if (n_ids >= SSH_MAX_IDENTITY_FILES ||
        8: 2089:		    strcasecmp(options.identity_files[i], "none") == 0) {
    #####: 2090:			free(options.identity_files[i]);
    #####: 2091:			options.identity_files[i] = NULL;
    #####: 2092:			continue;
        -: 2093:		}
        8: 2094:		cp = tilde_expand_filename(options.identity_files[i],
        -: 2095:		    original_real_uid);
        8: 2096:		filename = percent_expand(cp, "d", pwdir,
        -: 2097:		    "u", pwname, "l", thishost, "h", host,
        -: 2098:		    "r", options.user, (char *)NULL);
        8: 2099:		free(cp);
        8: 2100:		public = key_load_public(filename, NULL);
        8: 2101:		debug("identity file %s type %d", filename,
        -: 2102:		    public ? public->type : -1);
        8: 2103:		free(options.identity_files[i]);
        8: 2104:		identity_files[n_ids] = filename;
        8: 2105:		identity_keys[n_ids] = public;
        -: 2106:
        8: 2107:		if (++n_ids >= SSH_MAX_IDENTITY_FILES)
    #####: 2108:			continue;
        -: 2109:
        -: 2110:		/*
        -: 2111:		 * If no certificates have been explicitly listed then try
        -: 2112:		 * to add the default certificate variant too.
        -: 2113:		 */
        8: 2114:		if (options.num_certificate_files != 0)
    #####: 2115:			continue;
        8: 2116:		xasprintf(&cp, "%s-cert", filename);
        8: 2117:		public = key_load_public(cp, NULL);
        8: 2118:		debug("identity file %s type %d", cp,
        -: 2119:		    public ? public->type : -1);
        8: 2120:		if (public == NULL) {
        8: 2121:			free(cp);
        8: 2122:			continue;
        -: 2123:		}
    #####: 2124:		if (!key_is_cert(public)) {
    #####: 2125:			debug("%s: key %s type %s is not a certificate",
        -: 2126:			    __func__, cp, key_type(public));
    #####: 2127:			key_free(public);
    #####: 2128:			free(cp);
    #####: 2129:			continue;
        -: 2130:		}
        -: 2131:		/* NB. leave filename pointing to private key */
    #####: 2132:		identity_files[n_ids] = xstrdup(filename);
    #####: 2133:		identity_keys[n_ids] = public;
    #####: 2134:		n_ids++;
        -: 2135:	}
        -: 2136:
        2: 2137:	if (options.num_certificate_files > SSH_MAX_CERTIFICATE_FILES)
    #####: 2138:		fatal("%s: too many certificates", __func__);
        2: 2139:	for (i = 0; i < options.num_certificate_files; i++) {
    #####: 2140:		cp = tilde_expand_filename(options.certificate_files[i],
        -: 2141:		    original_real_uid);
    #####: 2142:		filename = percent_expand(cp, "d", pwdir,
        -: 2143:		    "u", pwname, "l", thishost, "h", host,
        -: 2144:		    "r", options.user, (char *)NULL);
    #####: 2145:		free(cp);
        -: 2146:
    #####: 2147:		public = key_load_public(filename, NULL);
    #####: 2148:		debug("certificate file %s type %d", filename,
        -: 2149:		    public ? public->type : -1);
    #####: 2150:		free(options.certificate_files[i]);
    #####: 2151:		options.certificate_files[i] = NULL;
    #####: 2152:		if (public == NULL) {
    #####: 2153:			free(filename);
    #####: 2154:			continue;
        -: 2155:		}
    #####: 2156:		if (!key_is_cert(public)) {
    #####: 2157:			debug("%s: key %s type %s is not a certificate",
        -: 2158:			    __func__, filename, key_type(public));
    #####: 2159:			key_free(public);
    #####: 2160:			free(filename);
    #####: 2161:			continue;
        -: 2162:		}
    #####: 2163:		certificate_files[n_certs] = filename;
    #####: 2164:		certificates[n_certs] = public;
    #####: 2165:		++n_certs;
        -: 2166:	}
        -: 2167:
        2: 2168:	options.num_identity_files = n_ids;
        2: 2169:	memcpy(options.identity_files, identity_files, sizeof(identity_files));
        2: 2170:	memcpy(options.identity_keys, identity_keys, sizeof(identity_keys));
        -: 2171:
        2: 2172:	options.num_certificate_files = n_certs;
        2: 2173:	memcpy(options.certificate_files,
        -: 2174:	    certificate_files, sizeof(certificate_files));
        2: 2175:	memcpy(options.certificates, certificates, sizeof(certificates));
        -: 2176:
        2: 2177:	explicit_bzero(pwname, strlen(pwname));
        2: 2178:	free(pwname);
        2: 2179:	explicit_bzero(pwdir, strlen(pwdir));
        2: 2180:	free(pwdir);
        2: 2181:}
        -: 2182:
        -: 2183:static void
    #####: 2184:main_sigchld_handler(int sig)
        -: 2185:{
    #####: 2186:	int save_errno = errno;
        -: 2187:	pid_t pid;
        -: 2188:	int status;
        -: 2189:
    #####: 2190:	while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
    #####: 2191:	    (pid < 0 && errno == EINTR))
        -: 2192:		;
        -: 2193:
    #####: 2194:	signal(sig, main_sigchld_handler);
    #####: 2195:	errno = save_errno;
    #####: 2196:}
